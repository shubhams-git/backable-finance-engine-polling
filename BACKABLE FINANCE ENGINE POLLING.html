<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Backable Finance Engine - Your Financial Command Center</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(
          135deg,
          #0f4c75 0%,
          #3282b8 30%,
          #bbe1fa 70%,
          #e3f2fd 100%
        );
        min-height: 100vh;
        color: #333;
        line-height: 1.6;
      }

      .container {
        max-width: 1000px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        text-align: center;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 40px;
        margin-bottom: 30px;
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        backdrop-filter: blur(10px);
        border: 2px solid #bbdefb;
      }

      .header h1 {
        color: #0f4c75;
        margin-bottom: 15px;
        font-size: 3em;
        font-weight: 800;
        background: linear-gradient(135deg, #0f4c75, #3282b8, #1976d2);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .header .subtitle {
        color: #3282b8;
        font-size: 1.5em;
        font-weight: 600;
        margin-bottom: 20px;
      }

      .intro-text {
        font-size: 1.2em;
        color: #666;
        max-width: 700px;
        margin: 0 auto 30px;
      }

      .progress-container {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 15px;
        padding: 20px;
        margin: 20px 0;
      }

      .progress-bar {
        width: 100%;
        height: 12px;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 6px;
        overflow: hidden;
        margin-bottom: 15px;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #0f4c75, #3282b8, #1976d2);
        border-radius: 6px;
        transition: width 0.5s ease;
        width: 0%;
      }

      .progress-text {
        text-align: center;
        color: #0f4c75;
        font-weight: 700;
        font-size: 1.1em;
      }

      .expansion-indicator {
        text-align: center;
        color: #3282b8;
        font-size: 1.3em;
        font-weight: 600;
        margin-bottom: 10px;
      }

      .connection-status {
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 10px 15px;
        border-radius: 20px;
        font-size: 0.9em;
        font-weight: 600;
        z-index: 1000;
        transition: all 0.3s ease;
      }

      .connection-status.connected {
        background: linear-gradient(135deg, #4caf50, #388e3c);
        color: white;
      }

      .connection-status.disconnected {
        background: linear-gradient(135deg, #f44336, #d32f2f);
        color: white;
      }

      .connection-status.checking {
        background: linear-gradient(135deg, #2196f3, #1976d2);
        color: white;
      }

      /* Assessment Selector */
      .assessment-selector {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 40px;
        margin-bottom: 30px;
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        backdrop-filter: blur(10px);
        border: 2px solid #bbdefb;
      }

      .assessment-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 25px;
        margin-top: 30px;
      }

      .assessment-card {
        background: white;
        border: 3px solid #bbdefb;
        border-radius: 15px;
        padding: 30px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
      }

      .assessment-card:hover {
        border-color: #0f4c75;
        transform: translateY(-5px);
        box-shadow: 0 15px 35px rgba(15, 76, 117, 0.2);
      }

      .assessment-card.completed {
        border-color: #4caf50;
        background: linear-gradient(
          135deg,
          rgba(76, 175, 80, 0.1),
          rgba(56, 142, 60, 0.1)
        );
      }

      .assessment-card-icon {
        font-size: 3em;
        margin-bottom: 15px;
        display: block;
      }

      .assessment-card-title {
        font-size: 1.4em;
        font-weight: 700;
        color: #0f4c75;
        margin-bottom: 10px;
      }

      .assessment-card-subtitle {
        font-size: 1em;
        color: #666;
        margin-bottom: 15px;
      }

      .assessment-card-description {
        font-size: 0.9em;
        color: #888;
        line-height: 1.4;
      }

      .completion-badge {
        position: absolute;
        top: 10px;
        right: 10px;
        background: #4caf50;
        color: white;
        border-radius: 50%;
        width: 25px;
        height: 25px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.8em;
        font-weight: bold;
      }

      /* User Input Section */
      .user-input-section {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 40px;
        margin-bottom: 30px;
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        backdrop-filter: blur(10px);
        border: 2px solid #bbdefb;
      }

      .user-input-section.hidden {
        display: none;
      }

      .user-input-section h2 {
        color: #0f4c75;
        margin-bottom: 25px;
        text-align: center;
        font-size: 2em;
      }

      .user-input-field {
        margin-bottom: 25px;
      }

      .user-input-field label {
        display: block;
        margin-bottom: 10px;
        font-weight: 600;
        color: #0f4c75;
        font-size: 1.1em;
      }

      .user-input-field input,
      .user-input-field select {
        width: 100%;
        padding: 15px;
        border: 2px solid #bbdefb;
        border-radius: 12px;
        font-size: 16px;
        transition: all 0.3s ease;
      }

      .user-input-field input:focus,
      .user-input-field select:focus {
        outline: none;
        border-color: #0f4c75;
        box-shadow: 0 0 0 3px rgba(15, 76, 117, 0.1);
        transform: translateY(-2px);
      }

      .start-button {
        width: 100%;
        padding: 18px;
        background: linear-gradient(135deg, #0f4c75, #3282b8);
        color: white;
        border: none;
        border-radius: 12px;
        font-size: 18px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .start-button:hover {
        transform: translateY(-3px);
        box-shadow: 0 10px 25px rgba(15, 76, 117, 0.3);
      }

      /* Assessment Content */
      .assessment-content {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 40px;
        margin-bottom: 30px;
        box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        backdrop-filter: blur(10px);
        border: 2px solid #bbdefb;
        display: none;
      }

      .assessment-content.active {
        display: block;
        animation: slideIn 0.5s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .assessment-header {
        text-align: center;
        margin-bottom: 40px;
      }

      .assessment-title {
        font-size: 2.5em;
        color: #0f4c75;
        margin-bottom: 15px;
        font-weight: 800;
      }

      .assessment-subtitle {
        font-size: 1.4em;
        color: #3282b8;
        font-weight: 600;
        margin-bottom: 20px;
      }

      .assessment-description {
        font-size: 1.1em;
        color: #666;
        margin-bottom: 30px;
        line-height: 1.6;
      }

      .dynamic-content {
        background: linear-gradient(
          135deg,
          rgba(15, 76, 117, 0.1),
          rgba(50, 130, 184, 0.05)
        );
        border: 2px solid #0f4c75;
        border-radius: 15px;
        padding: 25px;
        margin: 25px 0;
        font-style: italic;
        color: #0f4c75;
        font-weight: 500;
      }

      /* Question Styles */
      .question {
        margin-bottom: 50px;
        padding: 30px;
        background: linear-gradient(135deg, #f8fbff 0%, #fff 100%);
        border-radius: 20px;
        border: 2px solid #bbdefb;
        position: relative;
        overflow: hidden;
      }

      .question::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(90deg, #0f4c75, #3282b8, #1976d2);
      }

      .question-title {
        font-size: 1.4em;
        font-weight: 700;
        color: #0f4c75;
        margin-bottom: 15px;
      }

      .question-subtext {
        font-size: 1em;
        color: #666;
        margin-bottom: 25px;
        font-style: italic;
      }

      /* Financial Data Table */
      .financial-table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
        background: white;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      }

      .financial-table th {
        background: linear-gradient(135deg, #0f4c75, #3282b8);
        color: white;
        padding: 15px;
        text-align: left;
        font-weight: 600;
      }

      .financial-table td {
        padding: 15px;
        border-bottom: 1px solid #eee;
      }

      .financial-table input {
        width: 100%;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 6px;
        font-size: 14px;
      }

      /* File Upload */
      .file-upload-zone {
        border: 3px dashed #3282b8;
        border-radius: 15px;
        padding: 40px;
        text-align: center;
        background: linear-gradient(
          135deg,
          rgba(50, 130, 184, 0.05),
          rgba(187, 222, 251, 0.1)
        );
        margin: 20px 0;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .file-upload-zone:hover {
        border-color: #0f4c75;
        background: linear-gradient(
          135deg,
          rgba(15, 76, 117, 0.1),
          rgba(50, 130, 184, 0.1)
        );
      }

      .file-upload-zone.dragover {
        border-color: #1976d2;
        background: linear-gradient(
          135deg,
          rgba(25, 118, 210, 0.1),
          rgba(66, 165, 245, 0.1)
        );
      }

      .file-upload-icon {
        font-size: 3em;
        color: #3282b8;
        margin-bottom: 15px;
      }

      .file-upload-text {
        font-size: 1.2em;
        color: #0f4c75;
        font-weight: 600;
        margin-bottom: 10px;
      }

      .file-upload-subtext {
        font-size: 0.9em;
        color: #666;
      }

      .uploaded-files {
        margin-top: 20px;
      }

      .uploaded-file {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 15px;
        background: white;
        border: 1px solid #ddd;
        border-radius: 8px;
        margin-bottom: 10px;
      }

      .file-info {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .file-remove {
        background: #f44336;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 5px 10px;
        cursor: pointer;
        font-size: 0.8em;
      }

      /* Card Options */
      .card-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 25px;
      }

      .card-option {
        padding: 25px;
        background: white;
        border: 3px solid #bbdefb;
        border-radius: 15px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: center;
        position: relative;
        overflow: hidden;
      }

      .card-option:hover {
        border-color: #0f4c75;
        transform: translateY(-5px);
        box-shadow: 0 15px 35px rgba(15, 76, 117, 0.15);
      }

      .card-option.selected {
        border-color: #0f4c75;
        background: linear-gradient(
          135deg,
          rgba(15, 76, 117, 0.1),
          rgba(50, 130, 184, 0.1)
        );
        transform: translateY(-5px);
        box-shadow: 0 15px 35px rgba(15, 76, 117, 0.25);
      }

      .card-option-title {
        font-size: 1.3em;
        font-weight: 700;
        color: #0f4c75;
        margin-bottom: 10px;
      }

      .card-option-subtitle {
        font-size: 0.95em;
        color: #666;
        line-height: 1.5;
      }

      /* Multiple Choice */
      .checkbox-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 15px;
        margin-bottom: 25px;
      }

      .checkbox-option {
        padding: 20px;
        background: white;
        border: 2px solid #bbdefb;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
      }

      .checkbox-option:hover {
        border-color: #0f4c75;
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(15, 76, 117, 0.15);
      }

      .checkbox-option.selected {
        border-color: #0f4c75;
        background: linear-gradient(
          135deg,
          rgba(15, 76, 117, 0.1),
          rgba(50, 130, 184, 0.05)
        );
        transform: translateY(-3px);
      }

      .checkbox-option input[type="checkbox"] {
        position: absolute;
        opacity: 0;
      }

      .checkbox-option-label {
        font-weight: 600;
        color: #0f4c75;
        font-size: 1em;
      }

      /* Select Options */
      .select-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 15px;
        margin-bottom: 25px;
      }

      .select-option {
        padding: 20px;
        background: white;
        border: 2px solid #bbdefb;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: center;
      }

      .select-option:hover {
        border-color: #0f4c75;
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(15, 76, 117, 0.15);
      }

      .select-option.selected {
        border-color: #0f4c75;
        background: linear-gradient(
          135deg,
          rgba(15, 76, 117, 0.1),
          rgba(50, 130, 184, 0.05)
        );
        transform: translateY(-3px);
      }

      .select-option input[type="radio"] {
        position: absolute;
        opacity: 0;
      }

      .select-option-label {
        font-weight: 600;
        color: #0f4c75;
        font-size: 1em;
      }

      /* Single Slider */
      .slider-container {
        background: white;
        padding: 25px;
        border-radius: 15px;
        margin-bottom: 25px;
        border: 2px solid #bbdefb;
      }

      .slider-value {
        text-align: center;
        font-weight: 700;
        color: #0f4c75;
        font-size: 1.5em;
        margin-bottom: 15px;
      }

      .slider-input {
        width: 100%;
        height: 8px;
        border-radius: 4px;
        background: #bbdefb;
        outline: none;
        margin: 15px 0;
        -webkit-appearance: none;
      }

      .slider-input::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 25px;
        height: 25px;
        border-radius: 50%;
        background: linear-gradient(135deg, #0f4c75, #3282b8);
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(15, 76, 117, 0.3);
      }

      .slider-labels {
        display: flex;
        justify-content: space-between;
        font-size: 0.9em;
        color: #666;
        font-weight: 600;
      }

      /* Matrix Sliders */
      .matrix-slider-container {
        background: white;
        padding: 25px;
        border-radius: 15px;
        margin-bottom: 25px;
        border: 2px solid #bbdefb;
      }

      .matrix-slider-item {
        margin-bottom: 25px;
        padding: 20px;
        background: #f8fbff;
        border-radius: 12px;
      }

      .matrix-slider-label {
        font-weight: 600;
        color: #0f4c75;
        margin-bottom: 15px;
        font-size: 1em;
      }

      .matrix-slider-value {
        text-align: center;
        font-weight: 700;
        color: #0f4c75;
        font-size: 1.3em;
        margin-bottom: 10px;
      }

      .matrix-slider-input {
        width: 100%;
        height: 8px;
        border-radius: 4px;
        background: #bbdefb;
        outline: none;
        margin: 15px 0;
        -webkit-appearance: none;
      }

      .matrix-slider-input::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 25px;
        height: 25px;
        border-radius: 50%;
        background: linear-gradient(135deg, #0f4c75, #3282b8);
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(15, 76, 117, 0.3);
      }

      .matrix-slider-scale {
        display: flex;
        justify-content: space-between;
        font-size: 0.85em;
        color: #666;
        font-weight: 500;
      }

      /* Text Input */
      .text-input {
        width: 100%;
        padding: 20px;
        border: 2px solid #bbdefb;
        border-radius: 12px;
        font-size: 1em;
        transition: all 0.3s ease;
        min-height: 80px;
        resize: vertical;
        font-family: inherit;
      }

      .text-input:focus {
        outline: none;
        border-color: #0f4c75;
        box-shadow: 0 0 0 3px rgba(15, 76, 117, 0.1);
      }

      .char-counter {
        text-align: right;
        font-size: 0.85em;
        color: #666;
        margin-top: 8px;
        font-weight: 500;
      }

      /* Drag and Drop Ranking */
      .ranking-container {
        background: white;
        padding: 25px;
        border-radius: 15px;
        margin-bottom: 25px;
        border: 2px solid #bbdefb;
      }

      .ranking-item {
        background: #f8fbff;
        border: 2px solid #bbdefb;
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 10px;
        cursor: move;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 15px;
      }

      .ranking-item:hover {
        border-color: #0f4c75;
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(15, 76, 117, 0.1);
      }

      .ranking-item.dragging {
        opacity: 0.5;
        transform: rotate(5deg);
      }

      .ranking-item.drag-over {
        border: 2px dashed #1976d2;
        background: rgba(25, 118, 210, 0.1);
        transform: scale(1.02);
      }

      .ranking-number {
        background: linear-gradient(135deg, #0f4c75, #3282b8);
        color: white;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        flex-shrink: 0;
      }

      .ranking-text {
        font-weight: 600;
        color: #0f4c75;
      }

      .drag-handle {
        color: #999;
        font-size: 1.2em;
        margin-left: auto;
      }

      /* Auto-Save Indicator */
      .auto-save-indicator {
        position: absolute;
        top: 15px;
        right: 15px;
        font-size: 0.8em;
        padding: 5px 10px;
        border-radius: 15px;
        font-weight: 600;
      }

      .auto-save-indicator.saving {
        background: linear-gradient(135deg, #3282b8, #0f4c75);
        color: white;
      }

      .auto-save-indicator.saved {
        background: linear-gradient(135deg, #4caf50, #388e3c);
        color: white;
      }

      .auto-save-indicator.error {
        background: linear-gradient(135deg, #f44336, #d32f2f);
        color: white;
      }

      /* Navigation */
      .navigation {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 40px;
        padding: 25px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 20px;
        backdrop-filter: blur(10px);
      }

      .nav-button {
        padding: 15px 30px;
        border: none;
        border-radius: 12px;
        font-size: 1.1em;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .nav-button.primary {
        background: linear-gradient(135deg, #0f4c75, #3282b8);
        color: white;
      }

      .nav-button.primary:hover:not(:disabled) {
        transform: translateY(-3px);
        box-shadow: 0 10px 25px rgba(15, 76, 117, 0.3);
      }

      .nav-button.secondary {
        background: #bbdefb;
        color: #0f4c75;
      }

      .nav-button.secondary:hover:not(:disabled) {
        background: #90caf9;
        transform: translateY(-2px);
      }

      .nav-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none !important;
      }

      /* Final Section */
      .final-section {
        text-align: center;
        padding: 60px 40px;
        background: linear-gradient(135deg, #0f4c75, #3282b8, #1976d2);
        border-radius: 20px;
        color: white;
        display: none;
      }

      .final-section.active {
        display: block;
      }

      .final-title {
        font-size: 3em;
        font-weight: 800;
        margin-bottom: 25px;
      }

      .final-subtitle {
        font-size: 1.5em;
        margin-bottom: 30px;
        opacity: 0.9;
      }

      .submit-button {
        padding: 20px 50px;
        background: linear-gradient(135deg, #1976d2, #0f4c75);
        color: white;
        border: none;
        border-radius: 15px;
        font-size: 1.3em;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-top: 30px;
      }

      .submit-button:hover:not(:disabled) {
        transform: translateY(-3px);
        box-shadow: 0 15px 35px rgba(25, 118, 210, 0.4);
      }

      .submit-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      /* Status Messages */
      .status-message {
        text-align: center;
        padding: 20px;
        margin: 25px 0;
        border-radius: 12px;
        font-weight: 600;
        font-size: 1.1em;
      }

      .status-success {
        background: linear-gradient(135deg, #4caf50, #388e3c);
        color: white;
      }

      .status-error {
        background: linear-gradient(135deg, #f44336, #d32f2f);
        color: white;
      }

      .status-info {
        background: linear-gradient(135deg, #2196f3, #1976d2);
        color: white;
      }

      /* Loading Animation */
      .loading-spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: #fff;
        animation: spin 1s ease-in-out infinite;
        margin-left: 10px;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        .container {
          padding: 15px;
        }

        .header h1 {
          font-size: 2.2em;
        }

        .assessment-title {
          font-size: 1.8em;
        }

        .card-options {
          grid-template-columns: 1fr;
        }

        .checkbox-options {
          grid-template-columns: 1fr;
        }

        .navigation {
          flex-direction: column;
          gap: 15px;
        }

        .nav-button {
          width: 100%;
        }

        .connection-status {
          top: 10px;
          right: 10px;
          font-size: 0.8em;
          padding: 8px 12px;
        }

        .assessment-grid {
          grid-template-columns: 1fr;
        }

        .financial-table {
          font-size: 0.9em;
        }

        .financial-table th,
        .financial-table td {
          padding: 10px;
        }
      }
    </style>
  </head>
  <body>
    <!-- Connection Status Indicator -->
    <div class="connection-status checking" id="connectionStatus">
      🔄 Checking Connection...
    </div>

    <div class="container">
      <!-- User Input Section -->
      <div class="user-input-section" id="userInputSection">
        <h2>💰 Backable Finance Engine - Your Financial Command Center</h2>
        <p
          style="
            text-align: center;
            font-size: 1.1em;
            color: #666;
            margin-bottom: 30px;
          "
        >
          Never Alone, Always Ahead - Comprehensive Financial Intelligence
          Assessment
        </p>
        <div class="user-input-field">
          <label for="userIdInput">Enter Your User ID:</label>
          <input
            type="text"
            id="userIdInput"
            placeholder="e.g., 330 or your email"
            required
          />
        </div>
        <div class="user-input-field">
          <label for="businessNameInput">Business Name:</label>
          <input
            type="text"
            id="businessNameInput"
            placeholder="e.g., Your Company Name"
            required
          />
        </div>
        <div class="user-input-field">
          <label for="revenueRangeInput">Current Revenue Range:</label>
          <select id="revenueRangeInput" required>
            <option value="">Select your revenue range</option>
            <option value="under-100k">Under $100K</option>
            <option value="100k-500k">$100K - $500K</option>
            <option value="500k-1m">$500K - $1M</option>
            <option value="1m-2m">$1M - $2M</option>
            <option value="2m-5m">$2M - $5M</option>
            <option value="5m-10m">$5M - $10M</option>
            <option value="over-10m">Over $10M</option>
          </select>
        </div>
        <div class="user-input-field">
          <label for="challengeInput">Biggest Current Challenge:</label>
          <input
            type="text"
            id="challengeInput"
            placeholder="e.g., Cash flow, Growth funding, Cost control"
            required
          />
        </div>
        <div class="user-input-field">
          <label for="growthTargetInput"
            >Growth Target (% over next 3 years):</label
          >
          <input
            type="number"
            id="growthTargetInput"
            placeholder="e.g., 50"
            min="0"
            max="1000"
            required
          />
        </div>
        <button class="start-button" id="startButton">
          Begin Financial Assessment
        </button>
      </div>

      <!-- Assessment Selector -->
      <div
        class="assessment-selector"
        id="assessmentSelector"
        style="display: none"
      >
        <h2
          style="
            color: #0f4c75;
            margin-bottom: 25px;
            text-align: center;
            font-size: 2em;
          "
        >
          Choose Your Financial Assessment Path
        </h2>
        <p
          style="
            text-align: center;
            font-size: 1.1em;
            color: #666;
            margin-bottom: 30px;
          "
        >
          Each assessment builds your complete Financial Intelligence Profile
        </p>

        <div class="assessment-grid">
          <div
            class="assessment-card"
            onclick="selectAssessment('foundation')"
            id="foundationCard"
          >
            <div class="assessment-card-icon">🏗️</div>
            <div class="assessment-card-title">Financial Foundation</div>
            <div class="assessment-card-subtitle">
              Part 1 - Your Financial Truth
            </div>
            <div class="assessment-card-description">
              Map your financial journey, understand your numbers, and establish
              your relationship with money in business.
            </div>
          </div>

          <div
            class="assessment-card"
            onclick="selectAssessment('mastery')"
            id="masteryCard"
          >
            <div class="assessment-card-icon">⚡</div>
            <div class="assessment-card-title">Financial Mastery</div>
            <div class="assessment-card-subtitle">
              Part 2 - Strategic Command
            </div>
            <div class="assessment-card-description">
              Master cash flow, funding strategy, and build your financial
              future with strategic intelligence.
            </div>
          </div>

          <div
            class="assessment-card"
            onclick="selectAssessment('intelligence')"
            id="intelligenceCard"
          >
            <div class="assessment-card-icon">🧠</div>
            <div class="assessment-card-title">Financial Intelligence</div>
            <div class="assessment-card-subtitle">
              Part 3 - Profit Architecture
            </div>
            <div class="assessment-card-description">
              Analyze profit architecture, cost command, and build systems that
              drive smart decisions.
            </div>
          </div>
        </div>
      </div>

      <!-- Main Header (shown during assessment) -->
      <div class="header" id="assessmentHeader" style="display: none">
        <h1>💰 Backable Finance Engine</h1>
        <div class="subtitle">Your Financial Command Center</div>
        <p class="intro-text">
          Never Alone, Always Ahead - comprehensive financial intelligence and
          strategic command
        </p>
        <div class="progress-container">
          <div class="expansion-indicator" id="expansionIndicator">
            Financial Assessment
          </div>
          <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
          </div>
          <div class="progress-text" id="progressText">0% Complete</div>
        </div>
      </div>

      <!-- Assessment Content Container -->
      <div id="assessmentContainer"></div>

      <!-- Final Section -->
      <div class="final-section" id="finalSection">
        <div class="final-title">💎 Financial Intelligence Complete</div>
        <div class="final-subtitle">
          Your Financial Command Profile is Ready!
        </div>

        <p style="font-size: 1.2em; line-height: 1.7; margin: 30px 0">
          You've completed the comprehensive Backable Finance Engine assessment.
          Your personalized financial intelligence analysis is being generated
          to reveal opportunities and optimize your financial command.
        </p>

        <button class="submit-button" id="submitButton">
          Generate My Financial Intelligence Report
        </button>

        <div
          id="submission-status"
          class="status-message"
          style="display: none"
        ></div>
      </div>

      <!-- Navigation -->
      <div class="navigation" id="navigationSection" style="display: none">
        <button class="nav-button secondary" id="prevBtn" disabled>
          ← Previous
        </button>
        <div id="questionStatus" style="font-weight: 600; color: #0f4c75">
          Financial Assessment
        </div>
        <button class="nav-button primary" id="nextBtn">Next Question →</button>
      </div>
    </div>

    <script>
      // Configuration - Backend integration
      const API_BASE_URL = "http://192.168.0.131:8001";// For local development

      // Global variables
      let currentUserId = null;
      let currentBusinessName = null;
      let currentRevenueRange = null;
      let currentChallenge = null;
      let currentGrowthTarget = null;
      let assessmentStarted = false;
      let currentAssessment = null; // 'foundation', 'mastery', or 'intelligence'
      let currentQuestionIndex = 0;
      let responses = {};
      let questionStates = {};
      let startTime = new Date();
      let questionStartTimes = {};
      let backendConnected = false;
      let uploadedFiles = {
        profit_loss: [],
        balance_sheet: [],
        income_statement: [],
        management_reports: [],
        budget_analysis: [],
        supporting_documents: [],
      };

      // Add document categories configuration
      const documentCategories = {
        profit_loss: {
          endpoint: "/pdf_ai/profit_loss",
          title: "Profit & Loss Statements",
          description: "P&L, Income Statement, Revenue Reports",
          acceptedFormats: ["*"],
          maxFiles: 3,
          icon: "💹",
          examples: [
            "P&L Statements (Last 2 years + YTD)",
            "Income Statements",
            "Revenue Reports",
          ],
        },
        balance_sheet: {
          endpoint: "/pdf_ai/balance_sheet",
          title: "Balance Sheets",
          description: "Assets, Liabilities, Equity Statements",
          acceptedFormats: ["*"],
          maxFiles: 3,
          icon: "⚖️",
          examples: [
            "Balance Sheets (Last 2 years + current)",
            "Statement of Financial Position",
          ],
        },
        income_statement: {
          endpoint: "/pdf_ai/income_statement",
          title: "Income Statements",
          description: "Detailed Income & Expense Analysis",
          acceptedFormats: ["*"],
          maxFiles: 3,
          icon: "💰",
          examples: ["Detailed Income Statements", "Income vs Expense Reports"],
        },
        management_reports: {
          endpoint: "/pdf_ai/management_reports",
          title: "Management Reports",
          description: "Monthly/Quarterly internal reports",
          acceptedFormats: ["*"],
          maxFiles: 5,
          icon: "📈",
          examples: [
            "Management Reports (Monthly/Quarterly internal reports)",
            "Internal Performance Reports",
          ],
        },
        budget_analysis: {
          endpoint: "/pdf_ai/budget_analysis",
          title: "Budget vs Actual Reports",
          description: "Variance analysis and budget tracking",
          acceptedFormats: ["*"],
          maxFiles: 3,
          icon: "🎯",
          examples: ["Budget vs Actual Reports", "Variance Analysis Reports"],
        },
        supporting_documents: {
          endpoint: "/pdf_ai/supporting_documents",
          title: "Additional Analysis Documents",
          description: "Any other financial documents for analysis",
          acceptedFormats: ["*"],
          maxFiles: 10,
          icon: "📋",
          examples: [
            "Any other financial documents you'd like us to analyse",
            "Cash Flow Statements",
            "Financial Ratios",
          ],
        },
      };

      // Auto-save variables
      let autoSaveIndicator = null;
      let saveQueue = [];
      let isSaving = false;

      // Chapter timing tracking
      let chapterTimings = {};
      let currentChapterStartTime = null;
      let currentChapter = null;

      // Session metadata
      let sessionMetadata = {
        sessionId: "",
        startTime: null,
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        screenResolution: `${screen.width}x${screen.height}`,
        viewportSize: { width: window.innerWidth, height: window.innerHeight },
        devicePixelRatio: window.devicePixelRatio,
        colorDepth: screen.colorDepth,
        touchSupport: "ontouchstart" in window,
        cookiesEnabled: navigator.cookieEnabled,
        onlineStatus: navigator.onLine,
        referrer: "direct",
        entryUrl: window.location.href,
      };

      // Financial Assessment Questions
      const assessmentQuestions = {
        foundation: [
          {
            id: "f1.1",
            type: "select",
            section: "Your Financial Truth",
            number: "1",
            question:
              "Your financial year—when does it close the books on another chapter?",
            subText:
              "This helps me sync our insights with your natural business rhythm.",
            options: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December",
            ],
            required: true,
          },
          {
            id: "f1.2",
            type: "financial-table",
            section: "Your Financial Truth",
            number: "2",
            question: "Let's map your financial journey so far:",
            subText:
              "I know you said you were around [revenue_range], but let's get precise. These aren't just numbers—they're proof of how far you've already come.",
            tableType: "historical",
            required: true,
          },
          {
            id: "f1.3",
            type: "financial-table",
            section: "Your Financial Truth",
            number: "3",
            question: "Now, where you believe [business_name] is headed:",
            subText:
              "You mentioned wanting to hit [growth_target]% growth in three years. Let's break that dream into stepping stones. These projections? They're not wishes. They're commitments we're making together.",
            tableType: "projections",
            required: true,
          },
          {
            id: "f1.4",
            type: "card",
            section: "Your Financial Operating System",
            number: "4",
            question: "Your accounting reality check:",
            subText:
              "I'm not judging your choice—I'm understanding your financial language.",
            options: [
              {
                title: "Yes - we've got systems humming along",
                subtitle: ["Professional accounting system in place"],
              },
              {
                title: "No - we're still in spreadsheet survival mode",
                subtitle: ["Manual processes and basic tracking"],
              },
            ],
            followUp: {
              condition: "Yes - we've got systems humming along",
              question: "Which system has your back?",
              type: "select",
              options: [
                "Xero",
                "QuickBooks",
                "MYOB",
                "Sage",
                "FreshBooks",
                "Custom/Enterprise system",
                "Other",
              ],
            },
            required: true,
          },
          {
            id: "f1.5",
            type: "select",
            section: "Your Relationship with Money",
            number: "5",
            question: "How often do you actually look at your numbers?",
            subText: "This tells me whether money is your master or your tool.",
            options: [
              "When anxiety forces me to check",
              "Monthly, when the books demand attention",
              "Weekly, like checking in with an old friend",
              "Daily, because I need that control",
              "Constantly—my phone knows my bank balance better than I do",
            ],
            required: true,
          },
          {
            id: "f1.6",
            type: "select",
            section: "Your Relationship with Money",
            number: "6",
            question:
              "Those numbers you just gave me—how confident are you in them?",
            subText:
              "No judgement here. Knowing what you don't know is wisdom.",
            options: [
              "Dead certain - I could recite them in my sleep",
              "Pretty close - maybe off by 10% here or there",
              "Ballpark - I know the neighbourhood, not the address",
              "Educated guess - I'd need to check with my accountant",
            ],
            required: true,
          },
        ],
        mastery: [
          {
            id: "m1.1",
            type: "multi-slider",
            section: "The Cash Flow Engine",
            number: "1.1",
            question:
              "Rate how much each of these cash flow challenges affects your business:",
            subText:
              "Given the growth trajectory you've shared with us, cash flow isn't just about survival anymore—it's about having the ammunition ready when opportunities knock.",
            options: [
              "Customer Payment Delays - Clients paying late or extending terms",
              "Seasonal Fluctuations - Revenue ups and downs throughout the year",
              "Inventory Management - Cash tied up in stock or materials",
              "Supplier Payment Terms - Pressure from supplier payment schedules",
              "Growth Funding - Capital needed for expansion or opportunities",
              "Operational Cost Timing - Mismatched income and expense timing",
            ],
            min: 1,
            max: 10,
            step: 1,
            minLabel: "Not a problem",
            maxLabel: "Major headache",
          },
          {
            id: "m1.2",
            type: "select",
            section: "The Cash Flow Engine",
            number: "1.2",
            question: "What are your standard payment terms with customers?",
            options: [
              "Payment upfront - Cash before service, subscriptions, advance payments",
              "7 days - Quick turnaround",
              "14 days - Standard short terms",
              "30 days - Industry standard",
              "45+ days - Extended terms",
              "Variable depending on client - Flexible approach",
            ],
            required: true,
          },
          {
            id: "m1.3",
            type: "card",
            section: "The Cash Flow Engine",
            number: "1.3",
            question: "How would you describe your cash reserves right now?",
            options: [
              {
                title: "Storm Warning",
                subtitle: ["Constantly struggling to meet obligations"],
              },
              {
                title: "Cloudy Skies",
                subtitle: ["Tight but just managing to stay afloat"],
              },
              {
                title: "Partly Sunny",
                subtitle: ["Adequate for normal operations"],
              },
              {
                title: "Clear Skies",
                subtitle: ["Strong enough for unexpected costs"],
              },
              {
                title: "Perfect Conditions",
                subtitle: ["Positioned to seize opportunities"],
              },
            ],
            followUp: {
              question: "Any specific cash flow concerns keeping you awake?",
              type: "text",
              maxLength: 100,
              required: false,
            },
          },
          {
            id: "m2.1",
            type: "checkbox",
            section: "The Funding Strategy",
            number: "2.1",
            question: "What's currently funding your business operations?",
            subText:
              "You've built this business to [current_revenue], which means you understand capital deployment. The question now isn't whether you can access funding—it's whether you're using the right fuel for where you're headed.",
            options: [
              "Business loans",
              "Overdraft facilities",
              "Line of credit",
              "Investor capital",
              "Personal funds",
              "Equipment finance",
              "None of the above",
            ],
          },
          {
            id: "m2.2",
            type: "select",
            section: "The Funding Strategy",
            number: "2.2",
            question:
              "Are you looking for additional funding in the next 12 months?",
            options: [
              "Yes, definitely seeking funding",
              "Possibly, exploring options",
              "No immediate plans",
              "Unsure what we need",
            ],
            required: true,
          },
          {
            id: "m2.3",
            type: "text",
            section: "The Funding Strategy",
            number: "2.3",
            question: "What's your current debt situation?",
            subText:
              "Current loans, facilities, and terms - paint us the picture",
            placeholder:
              "Current loans, facilities, and terms - paint us the picture",
            maxLength: 100,
            required: false,
          },
          {
            id: "m3.1",
            type: "select",
            section: "The Intelligence Systems",
            number: "3.1",
            question:
              "How would you describe your current financial technology setup?",
            subText:
              "You mentioned you're using [accounting_system] for tracking—that's a solid start. But at your stage, the real question is whether your financial systems are giving you intelligence or just information.",
            options: [
              "Stone Age - Mainly manual processes, basic tracking",
              "Industrial Era - Standard accounting software",
              "Digital Age - Integrated systems with automation",
              "Space Age - Fully integrated with real-time intelligence",
              "Future State - AI-enhanced with predictive capabilities",
            ],
            required: true,
          },
          {
            id: "m3.2",
            type: "slider",
            section: "The Intelligence Systems",
            number: "3.2",
            question:
              "How well do your systems support actual business decisions?",
            min: 1,
            max: 10,
            step: 1,
            minLabel: "Decision Blocker",
            maxLabel: "Decision Accelerator",
          },
          {
            id: "m3.3",
            type: "checkbox",
            section: "The Intelligence Systems",
            number: "3.3",
            question:
              "What financial system improvements would transform your business?",
            subText: "Choose top 3",
            options: [
              "Better reporting and insights",
              "Integration with other business systems",
              "Automated processes and workflows",
              "Real-time data access",
              "Forecasting and predictive capabilities",
              "Happy with our current systems",
            ],
            maxSelections: 3,
          },
          {
            id: "m4.1",
            type: "checkbox",
            section: "The Strategic Intelligence",
            number: "4.1",
            question:
              "Which areas of your business need better financial visibility?",
            options: [
              "Profitability by product or service line",
              "Customer acquisition costs and lifetime value",
              "Project or job profitability analysis",
              "Cash flow forecasting accuracy",
              "Employee productivity and contribution",
              "Other specific intelligence needs",
            ],
          },
          {
            id: "m4.2",
            type: "slider",
            section: "The Strategic Intelligence",
            number: "4.2",
            question:
              "How easy is it to get the financial insights you actually need?",
            min: 1,
            max: 10,
            step: 1,
            minLabel: "Pulling teeth",
            maxLabel: "At my fingertips",
          },
          {
            id: "m5.1",
            type: "checkbox",
            section: "The Owner's Suite",
            number: "5.1",
            question:
              "How do you structure your compensation from the business?",
            subText:
              "Here's something we both know—you've moved beyond just paying yourself whatever's left over. At your level, how you structure your compensation affects everything from tax efficiency to business valuation.",
            options: [
              "Regular salary payments",
              "Dividends or profit distributions",
              "Performance-based bonuses",
              "Benefits (car, insurance, perks)",
              "Loans to/from the business",
            ],
          },
          {
            id: "m5.2",
            type: "select",
            section: "The Owner's Suite",
            number: "5.2",
            question:
              "How much do you need to take out of the business each month to fund your lifestyle?",
            options: [
              "Under $5,000 per month",
              "$5,000 - $10,000 per month",
              "$10,000 - $20,000 per month",
              "$20,000 - $50,000 per month",
              "Over $50,000 per month",
              "Prefer not to say",
            ],
            required: true,
          },
          {
            id: "m5.3",
            type: "text",
            section: "The Owner's Suite",
            number: "5.3",
            question:
              "If someone valued your business today, would your compensation structure help or hurt that valuation?",
            placeholder: "What would a buyer think about how you pay yourself?",
            maxLength: 100,
            required: false,
          },
          {
            id: "m6.1",
            type: "select",
            section: "The Exit Strategy",
            number: "6.1",
            question: "Have you ever had your business formally valued?",
            subText:
              "Whether you're thinking about it today or not, you're building something here. The businesses that reach sustainable growth always face the same question eventually: what's the endgame?",
            options: [
              "Yes, within the last 2 years",
              "Yes, but it's been 3+ years",
              "No, but I've thought about it",
              "No, and I'm not sure why I would",
              "No, but I'm curious what it's worth",
            ],
            required: true,
          },
          {
            id: "m6.2",
            type: "select",
            section: "The Exit Strategy",
            number: "6.2",
            question:
              "What's your rough estimate of what your business might be worth today?",
            subText: "This is just your gut feeling—no pressure to be accurate",
            options: [
              "Under $100K",
              "$100K-$500K",
              "$500K-$1M",
              "$1M-$2M",
              "$2M-$5M",
              "$5M-$10M",
              "Over $10M",
            ],
            required: true,
          },
          {
            id: "m6.3",
            type: "select",
            section: "The Exit Strategy",
            number: "6.3",
            question:
              "Have you ever considered acquiring another business or being acquired?",
            options: [
              "Actively exploring acquisition opportunities",
              "Would consider acquiring if right opportunity arose",
              "Open to being acquired by the right buyer",
              "Interested in mergers with complementary businesses",
              "Not interested in M&A activities",
              "Haven't really thought about it",
            ],
            required: true,
          },
          {
            id: "m6.4",
            type: "checkbox",
            section: "The Exit Strategy",
            number: "6.4",
            question:
              "What would make your business more attractive to a potential buyer?",
            subText: "Choose up to 3",
            options: [
              "Stronger financial systems and reporting",
              "Less dependence on owner/key personnel",
              "Diversified customer base",
              "Recurring revenue streams",
              "Documented processes and procedures",
              "Stronger management team",
              "Better profit margins",
              "Market leadership position",
            ],
            maxSelections: 3,
          },
          {
            id: "m7.1",
            type: "text",
            section: "The Final Intelligence",
            number: "7.1",
            question:
              "What have been your biggest financial surprises or lessons?",
            placeholder:
              "The moments that taught you the most about money in business",
            maxLength: 100,
            required: false,
          },
          {
            id: "m7.2",
            type: "select",
            section: "The Final Intelligence",
            number: "7.2",
            question:
              "How comfortable are you discussing your business finances?",
            options: [
              "Very comfortable - I live and breathe these numbers",
              "Somewhat comfortable - I understand the basics",
              "Neutral - It's just part of business",
              "Somewhat uncomfortable - Numbers aren't my strong suit",
              "Very uncomfortable - I'd rather have a root canal",
            ],
            required: true,
          },
        ],
        intelligence: [
          {
            id: "i0.1",
            type: "file-upload",
            section: "Document Intelligence",
            number: "0.1",
            question: "Upload Your Financial Documents",
            subText:
              "Sometimes the clearest insights come from seeing the complete financial story in context.",
            acceptedTypes: "all",
            required: false,
            categories: {
              "Core Documents": [
                "Last 2 Years Financial Statements (P&L, Balance Sheet)",
                "Year to date Financial Statements (accountant version)",
              ],
              "Additional Analysis Documents": [
                "Management Reports (Monthly/Quarterly internal reports)",
                "Budget vs Actual Reports",
                "Any other financial documents you'd like us to analyse",
              ],
            },
          },
          {
            id: "i0.2",
            type: "text",
            section: "Document Intelligence",
            number: "0.2",
            question:
              "Any context we should know before analysing your financials?",
            placeholder:
              "Seasonal patterns, one-off events, changes in the business...",
            subText: "Help us read between the lines",
            maxLength: 100,
            required: false,
          },
          {
            id: "i1.1",
            type: "text",
            section: "The Profit Architecture",
            number: "1.1",
            question:
              "Which of your products or services make you the most money?",
            placeholder: "Your profit champions—what's working?",
            maxLength: 100,
            required: true,
          },
          {
            id: "i1.2",
            type: "text",
            section: "The Profit Architecture",
            number: "1.2",
            question:
              "Which products or services are eating into your profits?",
            placeholder: "Your margin killers—what needs fixing?",
            maxLength: 100,
            required: true,
          },
          {
            id: "i1.3",
            type: "select",
            section: "The Profit Architecture",
            number: "1.3",
            question:
              "What happens between your quoted price and your actual profit?",
            subText:
              "The gap between promised profit and actual profit tells the real story of your business execution.",
            options: [
              "Minimal difference (<5%) - Quotes translate to reality",
              "Slight erosion (5-10%) - Small leakage but manageable",
              "Moderate gap (10-20%) - Noticeable profit shrinkage",
              "Significant loss (20-30%) - Major margin bleed",
              "Severe disconnect (>30%) - Quotes and reality in different universes",
              "Honestly don't measure this - Flying blind",
            ],
            required: true,
          },
          {
            id: "i2.1",
            type: "ranking",
            section: "The Cost Command",
            number: "2.1",
            question:
              "Rank your biggest cost concerns from most to least worrying:",
            subText:
              "With your current revenue at [current_revenue] and growing at the pace you've shown us, cost management becomes less about survival and more about strategic advantage.",
            options: [
              "Direct materials/Cost of goods sold",
              "Labour/Staffing costs",
              "Overheads/Fixed costs",
              "Marketing/Sales expenses",
              "Administrative expenses",
              "Taxation expenses",
              "Other operational costs",
            ],
            required: true,
          },
          {
            id: "i2.2",
            type: "slider",
            section: "The Cost Command",
            number: "2.2",
            question:
              "How well do you understand where your money actually goes?",
            min: 1,
            max: 10,
            step: 1,
            minLabel: "Completely Lost",
            maxLabel: "Total Control",
          },
          {
            id: "i2.3",
            type: "checkbox",
            section: "The Cost Command",
            number: "2.3",
            question:
              "Which cost areas are causing you the most concern right now?",
            subText: "Choose up to 3",
            options: [
              "Cost of Sales - Materials, direct costs, delivery",
              "People Power - Wages, salaries, contractor fees",
              "The Overhead Beast - Rent, utilities, maintenance",
              "Growth Investment - Marketing, advertising, promotion",
              "Money to Move Money - Interest, fees, taxes",
              "Everything Else - Software, subscriptions, surprises",
            ],
            maxSelections: 3,
          },
          {
            id: "i2.4",
            type: "text",
            section: "The Cost Command",
            number: "2.4",
            question: "Any specific cost challenges you're fighting right now?",
            placeholder: "Specific cost challenges or opportunities...",
            maxLength: 100,
            required: false,
          },
        ],
      };

      // API Functions
      async function makeAPICall(endpoint, method = "GET", data = null) {
        try {
          const options = {
            method: method,
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
            },
          };

          if (data) {
            options.body = JSON.stringify(data);
          }

          const response = await fetch(`${API_BASE_URL}${endpoint}`, options);

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          return await response.json();
        } catch (error) {
          console.error(`API call failed: ${method} ${endpoint}`, error);
          throw error;
        }
      }

      async function checkBackendConnection() {
        console.log("🔄 Checking finance backend connection...");
        updateConnectionStatus("checking");

        try {
          const response = await makeAPICall("/health");
          backendConnected = response.status === "healthy";
          console.log("✅ Finance backend connected:", backendConnected);
          updateConnectionStatus("connected");
          return backendConnected;
        } catch (error) {
          console.log("❌ Finance backend connection failed:", error.message);
          backendConnected = false;
          updateConnectionStatus("disconnected");
          return false;
        }
      }

      function updateConnectionStatus(status) {
        const statusElement = document.getElementById("connectionStatus");

        statusElement.className = `connection-status ${status}`;

        switch (status) {
          case "connected":
            statusElement.textContent = "✅ Connected";
            break;
          case "disconnected":
            statusElement.textContent = "❌ Offline Mode";
            break;
          case "checking":
            statusElement.textContent = "🔄 Checking...";
            break;
        }
      }

      // Revenue pattern analysis for dynamic content
      function analyzeRevenuePattern(historicalData) {
        if (!historicalData || !historicalData.revenue) return "stable";

        const revenues = [
          parseFloat(historicalData.revenue.twoYearsAgo) || 0,
          parseFloat(historicalData.revenue.lastYear) || 0,
          parseFloat(historicalData.revenue.currentYTD) || 0,
        ];

        // Calculate growth rates
        const growth1 =
          revenues[1] > 0
            ? ((revenues[1] - revenues[0]) / revenues[0]) * 100
            : 0;
        const growth2 =
          revenues[2] > 0
            ? ((revenues[2] - revenues[1]) / revenues[1]) * 100
            : 0;

        const avgGrowth = (growth1 + growth2) / 2;
        const volatility = Math.abs(growth1 - growth2);

        console.log("📊 Revenue Analysis:", {
          revenues,
          growth1,
          growth2,
          avgGrowth,
          volatility,
        });

        if (volatility > 30) return "volatile";
        if (avgGrowth > 10) return "growth";
        if (avgGrowth < -5) return "declining";
        return "stable";
      }

      function getDynamicContent(pattern, context = {}) {
        const contents = {
          growth: `We can see from your growth pattern that you're making smart moves. The businesses that sustain that kind of progress are the ones that can see around corners—they don't just track what happened, they predict what's coming.`,
          declining: `The businesses that turn things around aren't the ones with the best historical data—they're the ones that can see opportunities others miss and spot problems before they become crises.`,
          volatile: `Navigating unpredictable revenue requires more than good bookkeeping—it demands intelligence systems that help you see patterns in the chaos and prepare for multiple scenarios.`,
          stable: `Your steady revenue pattern shows disciplined business management. Now we can focus on optimizing that stability into strategic financial advantage.`,
        };

        return contents[pattern] || contents.stable;
      }

      // Assessment Management
      async function startFinanceAssessment() {
        console.log("🚀 Starting Backable Finance Engine Assessment");
        console.log("🎯 startFinanceAssessment function called successfully!");

        const userIdInput = document.getElementById("userIdInput");
        const businessNameInput = document.getElementById("businessNameInput");
        const revenueRangeInput = document.getElementById("revenueRangeInput");
        const challengeInput = document.getElementById("challengeInput");
        const growthTargetInput = document.getElementById("growthTargetInput");

        const userId = userIdInput.value.trim();
        const businessName = businessNameInput.value.trim();
        const revenueRange = revenueRangeInput.value;
        const challenge = challengeInput.value.trim();
        const growthTarget = growthTargetInput.value;

        if (
          !userId ||
          !businessName ||
          !revenueRange ||
          !challenge ||
          !growthTarget
        ) {
          alert("Please fill in all required fields to continue.");
          return;
        }

        currentUserId = userId;
        currentBusinessName = businessName;
        currentRevenueRange = revenueRange;
        currentChallenge = challenge;
        currentGrowthTarget = growthTarget;

        console.log("✅ User details set:", {
          userId: currentUserId,
          businessName: currentBusinessName,
          revenueRange: currentRevenueRange,
          challenge: currentChallenge,
          growthTarget: currentGrowthTarget,
        });

        // Show loading state
        const startButton = document.getElementById("startButton");
        const originalText = startButton.innerHTML;
        startButton.innerHTML =
          'Loading Financial Intelligence... <div class="loading-spinner"></div>';
        startButton.disabled = true;

        try {
          // Check backend connection
          await checkBackendConnection();

          // Load any existing progress
          if (backendConnected) {
            await loadExistingProgress();
          } else {
            // If backend not connected, still try to load documents 
            // (some users may have connectivity issues with progress but not documents)
            console.log("⚠️ Backend not connected for progress, but attempting to load documents anyway");
            try {
              await loadUserDocuments();
            } catch (error) {
              console.log("❌ Could not load documents without backend connection");
            }
          }

          // Hide user input and show assessment selector
          document.getElementById("userInputSection").classList.add("hidden");
          document.getElementById("assessmentSelector").style.display = "block";

          // Update completion status of assessment cards
          updateAssessmentCardStatus();

          // Set up session metadata
          sessionMetadata = {
            ...sessionMetadata,
            sessionId: `finance_engine_sess_${Date.now()}_${Math.random()
              .toString(36)
              .substr(2, 9)}`,
            startTime: new Date().toISOString(),
            userId: currentUserId,
            businessName: currentBusinessName,
            revenueRange: currentRevenueRange,
            challenge: currentChallenge,
            growthTarget: currentGrowthTarget,
          };

          assessmentStarted = true;
          startTime = new Date();

          console.log("✅ Finance assessment initialization complete");
        } catch (error) {
          console.error("❌ Error starting finance assessment:", error);
          showStatusMessage(
            `❌ Error loading assessment: ${error.message}`,
            "error"
          );

          // Restore button state
          startButton.innerHTML = originalText;
          startButton.disabled = false;
        }
      }

      async function loadExistingProgress() {
  try {
    console.log(`🔄 Loading existing finance progress for user: ${currentUserId}`);
    
    const response = await makeAPICall(
      `/finance_assessment_progress/${currentUserId}`
    );

    console.log("📡 API Response received:", {
      status: response.status,
      hasAssessmentData: !!response.assessment_data,
      hasAssessments: !!response.assessments,
      responseKeys: Object.keys(response)
    });

    if (response.status === "found") {
      console.log("📥 Found existing finance progress, processing data...");
      
      let processedResponses = 0;
      let totalResponses = 0;

      // METHOD 1: Try to load from response.assessments (new structure)
      if (response.assessments && Object.keys(response.assessments).length > 0) {
        console.log("📊 Loading from assessments structure:", Object.keys(response.assessments));
        
        Object.keys(response.assessments).forEach((assessmentType) => {
          const assessmentData = response.assessments[assessmentType];
          console.log(`🔍 Processing ${assessmentType} assessment:`, {
            hasResponses: !!assessmentData.responses,
            responseCount: assessmentData.responses ? assessmentData.responses.length : 0
          });
          
          if (assessmentData.responses && Array.isArray(assessmentData.responses)) {
            assessmentData.responses.forEach((resp, index) => {
              try {
                if (resp.question_id) {
                  responses[resp.question_id] = resp;
                  questionStates[resp.question_id] = {
                    status: "completed",
                    first_answered_at: resp.answered_at,
                    last_modified_at: resp.last_modified_at || resp.answered_at,
                    modification_count: 0,
                  };
                  processedResponses++;
                  console.log(`✅ Restored response ${processedResponses}: ${resp.question_id} (${assessmentType})`);
                } else {
                  console.warn(`⚠️ Response ${index} in ${assessmentType} missing question_id:`, resp);
                }
                totalResponses++;
              } catch (responseError) {
                console.error(`❌ Error processing response ${index} in ${assessmentType}:`, responseError, resp);
              }
            });
          } else {
            console.log(`ℹ️ No responses found in ${assessmentType} assessment`);
          }
        });
      }

      // METHOD 2: Try to load from assessment_data.assessments (fallback)
      else if (response.assessment_data && response.assessment_data.assessments) {
        console.log("📊 Loading from assessment_data.assessments structure:", Object.keys(response.assessment_data.assessments));
        
        Object.keys(response.assessment_data.assessments).forEach((assessmentType) => {
          const assessmentData = response.assessment_data.assessments[assessmentType];
          console.log(`🔍 Processing ${assessmentType} from assessment_data:`, {
            hasResponses: !!assessmentData.responses,
            responseCount: assessmentData.responses ? assessmentData.responses.length : 0
          });
          
          if (assessmentData.responses && Array.isArray(assessmentData.responses)) {
            assessmentData.responses.forEach((resp, index) => {
              try {
                if (resp.question_id) {
                  responses[resp.question_id] = resp;
                  questionStates[resp.question_id] = {
                    status: "completed",
                    first_answered_at: resp.answered_at,
                    last_modified_at: resp.last_modified_at || resp.answered_at,
                    modification_count: 0,
                  };
                  processedResponses++;
                  console.log(`✅ Restored response ${processedResponses}: ${resp.question_id} (${assessmentType})`);
                } else {
                  console.warn(`⚠️ Response ${index} in ${assessmentType} missing question_id:`, resp);
                }
                totalResponses++;
              } catch (responseError) {
                console.error(`❌ Error processing response ${index} in ${assessmentType}:`, responseError, resp);
              }
            });
          }
        });
      }

      // METHOD 3: Try direct responses array (legacy support)
      else if (response.assessment_data && response.assessment_data.responses) {
        console.log("📊 Loading from direct responses array:", response.assessment_data.responses.length);
        
        response.assessment_data.responses.forEach((resp, index) => {
          try {
            if (resp.question_id) {
              responses[resp.question_id] = resp;
              questionStates[resp.question_id] = {
                status: "completed",
                first_answered_at: resp.answered_at,
                last_modified_at: resp.last_modified_at || resp.answered_at,
                modification_count: 0,
              };
              processedResponses++;
              console.log(`✅ Restored response ${processedResponses}: ${resp.question_id}`);
            } else {
              console.warn(`⚠️ Response ${index} missing question_id:`, resp);
            }
            totalResponses++;
          } catch (responseError) {
            console.error(`❌ Error processing direct response ${index}:`, responseError, resp);
          }
        });
      } else {
        console.log("ℹ️ No recognizable response structure found in saved data");
        console.log("📊 Available data keys:", {
          responseKeys: Object.keys(response),
          assessmentDataKeys: response.assessment_data ? Object.keys(response.assessment_data) : null
        });
      }

      // Load uploaded files if available - DETAILED DEBUG LOGGING
      console.log("🔍 DEBUG: Checking for uploaded files in response...");
      console.log("   - response.assessment_data exists:", !!response.assessment_data);
      console.log("   - response.assessment_data keys:", response.assessment_data ? Object.keys(response.assessment_data) : "N/A");
      console.log("   - response.assessment_data.uploaded_files exists:", !!(response.assessment_data && response.assessment_data.uploaded_files));
      
      let filesLoaded = false;
      
      // METHOD 1: Try loading from new structure (assessment_data.uploaded_files)
      if (response.assessment_data && response.assessment_data.uploaded_files) {
        console.log("📁 LOADING FILES FROM NEW STRUCTURE (assessment_data.uploaded_files)");
        console.log("   - Raw uploaded_files data:", JSON.stringify(response.assessment_data.uploaded_files, null, 2));
        
        try {
          const fileCategories = Object.keys(response.assessment_data.uploaded_files);
          console.log(`   - Found ${fileCategories.length} file categories:`, fileCategories);
          
          fileCategories.forEach(category => {
            const categoryFiles = response.assessment_data.uploaded_files[category];
            console.log(`   - Category "${category}": ${categoryFiles ? categoryFiles.length : 0} files`);
            
            if (categoryFiles && categoryFiles.length > 0) {
              categoryFiles.forEach((file, index) => {
                console.log(`     * File ${index + 1}: ${file.originalFile ? file.originalFile.name : 'Unknown name'} (${file.uploadedAt || 'Unknown date'})`);
              });
            }
            
            uploadedFiles[category] = categoryFiles || [];
          });
          
          filesLoaded = true;
          console.log("✅ FILES LOADED FROM NEW STRUCTURE");
          
        } catch (fileError) {
          console.error("❌ Error loading from new structure:", fileError);
        }
      }
      
      // METHOD 2: Try loading from old structure (individual responses) - FALLBACK for OLD CLIENTS
      if (!filesLoaded && response.assessments && Object.keys(response.assessments).length > 0) {
        console.log("📁 CHECKING OLD STRUCTURE (individual responses) - FALLBACK FOR OLD CLIENTS");
        
        Object.keys(response.assessments).forEach((assessmentType) => {
          const assessmentData = response.assessments[assessmentType];
          if (assessmentData.responses) {
            assessmentData.responses.forEach((savedResponse) => {
              if (savedResponse.question_type === 'file-upload' && savedResponse.response_data && savedResponse.response_data.uploaded_files) {
                console.log(`   - Found old file structure in ${assessmentType} assessment:`, Object.keys(savedResponse.response_data.uploaded_files));
                
                const uploadData = savedResponse.response_data.uploaded_files || {};
                Object.keys(uploadData).forEach((categoryKey) => {
                  if (uploadData[categoryKey] && uploadData[categoryKey].length > 0) {
                    console.log(`   - Loading ${uploadData[categoryKey].length} files for category: ${categoryKey}`);
                    uploadedFiles[categoryKey] = uploadData[categoryKey] || [];
                    filesLoaded = true;
                  }
                });
              }
            });
          }
        });
        
        if (filesLoaded) {
          console.log("✅ FILES LOADED FROM OLD STRUCTURE - LEGACY CLIENT SUPPORT");
        }
      }
      
      if (filesLoaded) {
        console.log("📁 UPLOADED FILES RESTORATION COMPLETE");
        console.log("   - uploadedFiles object:", Object.keys(uploadedFiles));
        console.log("   - Total files loaded:", Object.values(uploadedFiles).flat().length);
        
        // Update displays for all categories
        Object.keys(documentCategories).forEach(categoryKey => {
          FinanceEngine.updateCategoryFileDisplay(categoryKey);
          console.log(`   - Updated display for ${categoryKey}: ${uploadedFiles[categoryKey] ? uploadedFiles[categoryKey].length : 0} files`);
        });
      } else {
        console.log("⚪ NO UPLOADED FILES FOUND IN ANY STRUCTURE");
        console.log("   - This could mean:");
        console.log("     * Client has never uploaded files");
        console.log("     * Files weren't saved properly to backend");
        console.log("     * Backend response structure changed");
        
        // Initialize empty file containers and update displays
        Object.keys(documentCategories).forEach(categoryKey => {
          if (!uploadedFiles[categoryKey]) {
            uploadedFiles[categoryKey] = [];
          }
          FinanceEngine.updateCategoryFileDisplay(categoryKey);
        });
      }

      // Summary logging
      console.log("📊 FINANCE PROGRESS LOADING SUMMARY:");
      console.log(`   ✅ Successfully processed: ${processedResponses}/${totalResponses} responses`);
      console.log(`   📝 Total questions restored: ${Object.keys(responses).length}`);
      console.log(`   📁 File categories loaded: ${Object.keys(uploadedFiles).length}`);
      console.log(`   ⏰ Data from: ${response.updated_at || response.created_at || 'unknown time'}`);

      if (processedResponses > 0) {
        // Log sample of restored questions for verification
        const sampleQuestions = Object.keys(responses).slice(0, 5);
        console.log("📝 Sample restored questions:", sampleQuestions);
        
        // Load documents directly from database (this fixes the document persistence issue)
        await loadUserDocuments();
        
        // Update UI to reflect loaded data
        updateAssessmentCardStatus();
        
        return true;
      } else {
        console.warn("⚠️ No responses were successfully loaded despite finding saved data");
        return false;
      }

    } else if (response.status === "not_found") {
      console.log("ℹ️ No saved finance progress found for this user - starting fresh");
      return false;
    } else {
      console.warn("⚠️ Unexpected response status:", response.status);
      return false;
    }

  } catch (error) {
    console.error("❌ Error loading existing finance progress:");
    console.error("   Error type:", error.constructor.name);
    console.error("   Error message:", error.message);
    console.error("   Full error:", error);
    
    // Check if it's a network error
    if (error.message.includes('fetch')) {
      console.error("🌐 Network error - check if backend is running and accessible");
    }
    
    return false;
  }
}

      async function loadUserDocuments(userId = null) {
        const targetUserId = userId || currentUserId;
        try {
          console.log(`📄 Loading documents directly from database for user: ${targetUserId}`);
          console.log(`🔍 DEBUG: Full API URL will be: ${API_BASE_URL}/finance_documents/${targetUserId}`);
          
          const response = await makeAPICall(`/finance_documents/${targetUserId}`);
          
          console.log(`📡 DEBUG: API Response for user ${targetUserId}:`, {
            responseExists: !!response,
            responseKeys: response ? Object.keys(response) : null,
            hasDocuments: response && response.documents ? true : false,
            documentsLength: response && response.documents ? response.documents.length : 'N/A',
            totalDocuments: response ? response.total_documents : 'N/A',
            categoriesFound: response ? response.categories_found : 'N/A'
          });
          
          if (response && response.documents && response.documents.length > 0) {
            console.log(`✅ Found ${response.documents.length} documents in database`);
            
            // Reset uploadedFiles to avoid duplicates
            Object.keys(documentCategories).forEach(categoryKey => {
              uploadedFiles[categoryKey] = [];
            });
            
            // Process each document from database
            response.documents.forEach((doc, index) => {
              const categoryKey = doc.category;
              
              if (!uploadedFiles[categoryKey]) {
                uploadedFiles[categoryKey] = [];
              }
              
              // Convert database document to frontend format
              const fileData = {
                originalFile: {
                  name: doc.original_name,
                  size: doc.file_size,
                  type: doc.file_type || 'application/pdf'
                },
                file_id: doc.file_id,
                uploadedAt: doc.upload_timestamp,
                processingStatus: doc.processing_status,
                extractionStatus: doc.extraction_status,
                extractedData: doc.extracted_data,
                geminiAnalysis: doc.gemini_analysis,
                financialRatios: doc.financial_ratios,
                analysisMetadata: doc.analysis_metadata
              };
              
              uploadedFiles[categoryKey].push(fileData);
              
              console.log(`📁 Loaded: ${doc.original_name} (${categoryKey}) - Status: ${doc.processing_status}`);
            });
            
            // Update all category displays
            Object.keys(documentCategories).forEach(categoryKey => {
              FinanceEngine.updateCategoryFileDisplay(categoryKey);
            });
            
            // Update the document upload response to reflect loaded documents
            FinanceEngine.updateDocumentUploadResponse();
            
            console.log("✅ Documents successfully loaded from database and UI updated");
            
            return true;
          } else {
            console.log("ℹ️ No documents found in database for this user");
            return false;
          }
          
        } catch (error) {
          console.error("❌ Error loading documents from database:", error);
          return false;
        }
      }

      function updateAssessmentCardStatus() {
        const assessmentTypes = ["foundation", "mastery", "intelligence"];

        assessmentTypes.forEach((type) => {
          const card = document.getElementById(`${type}Card`);
          const questions = assessmentQuestions[type];
          const completedQuestions = questions.filter(
            (q) => responses[q.id]
          ).length;
          const completionRate = completedQuestions / questions.length;

          if (completionRate >= 0.8) {
            card.classList.add("completed");
            if (!card.querySelector(".completion-badge")) {
              const badge = document.createElement("div");
              badge.className = "completion-badge";
              badge.textContent = "✓";
              card.appendChild(badge);
            }
          }

          console.log(
            `📊 ${type} completion: ${completedQuestions}/${
              questions.length
            } (${Math.round(completionRate * 100)}%)`
          );
        });
      }

      function selectAssessment(assessmentType) {
        console.log(`🎯 Selected assessment: ${assessmentType}`);

        currentAssessment = assessmentType;
        currentQuestionIndex = 0;

        // Hide assessment selector
        document.getElementById("assessmentSelector").style.display = "none";

        // Show assessment header and navigation
        document.getElementById("assessmentHeader").style.display = "block";
        document.getElementById("navigationSection").style.display = "flex";

        // Load existing progress for this assessment if available
        const nextQuestionIndex = findNextQuestionIndex(assessmentType);
        showQuestion(nextQuestionIndex);

        console.log(
          `✅ Started ${assessmentType} assessment at question ${
            nextQuestionIndex + 1
          }`
        );
      }

      function findNextQuestionIndex(assessmentType) {
        const questions = assessmentQuestions[assessmentType];
        for (let i = 0; i < questions.length; i++) {
          if (!responses[questions[i].id]) {
            return i;
          }
        }
        return questions.length - 1; // Show last question if all completed
      }

      function showQuestion(questionIndex) {
        if (!currentAssessment) return;

        const questions = assessmentQuestions[currentAssessment];
        console.log(
          `👁️ Showing ${currentAssessment} question ${questionIndex + 1} of ${
            questions.length
          }`
        );

        if (questionIndex >= questions.length) {
          showAssessmentComplete();
          return;
        }

        currentQuestionIndex = questionIndex;
        const question = questions[questionIndex];

        // Replace placeholders in question text
        question.question = replacePlaceholders(question.question);
        if (question.subText) {
          question.subText = replacePlaceholders(question.subText);
        }

        trackChapterTiming(question.section);

        const questionHTML = generateQuestionHTML(question);
        document.getElementById("assessmentContainer").innerHTML = questionHTML;

        autoSaveIndicator = null;

        if (!questionStates[question.id]) {
          initializeQuestionState(question.id);
        }

        setTimeout(() => {
          restoreQuestionResponse(question);
        }, 100);

        updateNavigation();
        updateProgress();
      }

      function replacePlaceholders(text) {
        return text
          .replace(/\[business_name\]/g, currentBusinessName || "your business")
          .replace(
            /\[revenue_range\]/g,
            currentRevenueRange || "your current revenue level"
          )
          .replace(
            /\[challenge\]/g,
            currentChallenge || "your biggest challenge"
          )
          .replace(
            /\[growth_target\]/g,
            currentGrowthTarget || "significant growth"
          )
          .replace(
            /\[current_revenue\]/g,
            currentRevenueRange || "your current level"
          )
          .replace(
            /\[accounting_system\]/g,
            getAccountingSystem() || "your financial systems"
          );
      }

      function getAccountingSystem() {
        const accountingResponse = responses["f1.4"];
        if (accountingResponse && accountingResponse.followUp) {
          return accountingResponse.followUp.selected_option;
        }
        return null;
      }

      function generateQuestionHTML(question) {
        const questionId = question.id;
        const safeId = createSafeId(questionId);

        // Add dynamic content for strategic intelligence section
        let dynamicContentHTML = "";
        if (
          question.section === "The Strategic Intelligence" &&
          question.number === "4.1"
        ) {
          const historicalData = getHistoricalFinancialData();
          const pattern = analyzeRevenuePattern(historicalData);
          const dynamicText = getDynamicContent(pattern);

          dynamicContentHTML = `
                    <div class="dynamic-content">
                        ${dynamicText}
                    </div>
                `;
        }

        let html = `
                <div class="assessment-content active">
                    <div class="assessment-header">
                        <h2 class="assessment-title">${question.section}</h2>
                        <p class="assessment-subtitle">${getAssessmentSubtitle(
                          currentAssessment
                        )}</p>
                    </div>
                    
                    ${dynamicContentHTML}
                    
                    <div class="question" data-question-id="${safeId}">
                        <h3 class="question-title">${question.number}. ${
          question.question
        }</h3>
                        ${
                          question.subText
                            ? `<p class="question-subtext">${question.subText}</p>`
                            : ""
                        }
            `;

        switch (question.type) {
          case "financial-table":
            html += generateFinancialTableHTML(question);
            break;
          case "file-upload":
            html += generateFileUploadHTML(question);
            break;
          case "ranking":
            html += generateRankingHTML(question);
            break;
          case "card":
            html += generateCardHTML(question, questionId);
            break;
          case "checkbox":
            html += generateCheckboxHTML(question, questionId);
            break;
          case "text":
            html += generateTextHTML(question, questionId);
            break;
          case "slider":
            html += generateSliderHTML(question, questionId);
            break;
          case "multi-slider":
            html += generateMultiSliderHTML(question, questionId);
            break;
          case "select":
            html += generateSelectHTML(question, questionId);
            break;
          default:
            html += `<p>Unknown question type: ${question.type}</p>`;
        }

        html += `
                    </div>
                </div>
            `;

        return html;
      }

      function getAssessmentSubtitle(assessmentType) {
        const subtitles = {
          foundation: "Part 1 - Your Financial Truth",
          mastery: "Part 2 - Strategic Financial Command",
          intelligence: "Part 3 - Profit Architecture & Intelligence",
        };
        return subtitles[assessmentType] || "Financial Assessment";
      }

      function generateFinancialTableHTML(question) {
        const isHistorical = question.tableType === "historical";
        const columns = isHistorical
          ? ["Description", "2 Years Ago", "Last Year", "Current YTD"]
          : ["Description", "This Year", "Next Year", "In 2 Years"];

        const rows = ["Revenue", "Gross Profit", "Net Profit"];

        let html = `
                <div class="financial-table-container">
                    <table class="financial-table">
                        <thead>
                            <tr>
                                ${columns
                                  .map((col) => `<th>${col}</th>`)
                                  .join("")}
                            </tr>
                        </thead>
                        <tbody>
            `;

        rows.forEach((row) => {
          html += `<tr><td><strong>${row}</strong></td>`;
          for (let i = 1; i < columns.length; i++) {
            const fieldId = `${question.id}_${row
              .toLowerCase()
              .replace(" ", "_")}_${i}`;
            html += `<td><input type="number" id="${fieldId}" placeholder="$0" onchange="FinanceEngine.handleTableInput('${
              question.id
            }', '${isHistorical ? "historical" : "projections"}')"></td>`;
          }
          html += "</tr>";
        });

        html += `
                        </tbody>
                    </table>
                    <p style="font-size: 0.9em; color: #666; margin-top: 10px; text-align: center;">
                        ${
                          isHistorical
                            ? "All figures should be for your complete financial year periods (except Current YTD)"
                            : "These projections are commitments we're making together"
                        }
                    </p>
                </div>
            `;

        return html;
      }

      function generateFileUploadHTML(question) {
        return `
        <div class="file-upload-section">
            <!-- Processing Method Toggle -->
            <div style="background: #e3f2fd; border: 2px solid #1976d2; border-radius: 12px; padding: 15px; margin-bottom: 25px; text-align: center;">
                <div style="display: flex; align-items: center; justify-content: center; gap: 15px; margin-bottom: 10px;">
                    <span style="font-weight: 600; color: #1976d2;">📊 Processing Method:</span>
                    <button id="processingMethodToggle" onclick="FinanceEngine.toggleProcessingMethod(); updateProcessingMethodDisplay();" 
                            style="background: #1976d2; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600; transition: all 0.3s;">
                        <span id="currentMethodText">Blob-First (Recommended)</span>
                    </button>
                </div>
                <div id="methodDescription" style="font-size: 0.85em; color: #666;">
                    ⚡ Enhanced reliability with blob storage, retry mechanism & polling for long operations
                </div>
            </div>
            
            <p style="text-align: center; margin-bottom: 30px; font-size: 1.1em; color: #0f4c75; font-weight: 600;">
                Upload your documents by category - all files stored securely and processed with AI analysis
            </p>
            
            ${Object.entries(documentCategories)
              .map(
                ([categoryKey, category]) => `
                <div style="margin-bottom: 30px; background: white; border: 2px solid #bbdefb; border-radius: 15px; padding: 25px;">
                    <h4 style="color: #0f4c75; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 1.5em;">${category.icon}</span>
                        ${category.title}
                    </h4>
                    <p style="color: #666; margin-bottom: 15px; font-size: 0.9em;">${
                      category.description
                    }</p>
                    
                    <div class="file-upload-zone" onclick="FinanceEngine.triggerCategoryUpload('${categoryKey}')" 
                         ondrop="FinanceEngine.handleCategoryDrop(event, '${categoryKey}')" 
                         ondragover="FinanceEngine.handleDragOver(event)" 
                         ondragleave="FinanceEngine.handleDragLeave(event)"
                         style="margin-bottom: 15px; padding: 20px;">
                        <div class="file-upload-icon" style="font-size: 2em;">${
                          category.icon
                        }</div>
                        <div class="file-upload-text">Click to upload ${
                          category.title
                        }</div>
                        <div class="file-upload-subtext">All formats accepted • Max ${
                          category.maxFiles
                        } files • Auto-converted to PDF</div>
                    </div>
                    
                    <input type="file" id="fileInput_${categoryKey}" multiple 
                           accept="*/*" 
                           style="display: none;" 
                           onchange="FinanceEngine.handleCategoryFileSelect(event, '${categoryKey}')">
                    
                    <div class="uploaded-files" id="uploadedFiles_${categoryKey}"></div>
                    <div class="processing-status" id="processingStatus_${categoryKey}"></div>
                    
                    <div style="margin-top: 15px;">
                        <p style="font-size: 0.85em; color: #666; font-weight: 600;">Examples:</p>
                        <ul style="font-size: 0.8em; color: #888; padding-left: 20px;">
                            ${category.examples
                              .map((ex) => `<li>${ex}</li>`)
                              .join("")}
                        </ul>
                    </div>
                </div>
            `
              )
              .join("")}
        </div>
    `;
      }

      function generateRankingHTML(question) {
        return `
                <div class="ranking-container" id="ranking_${question.id}">
                    <p style="margin-bottom: 20px; font-weight: 600; color: #0f4c75;">Drag to reorder from most to least worrying:</p>
                    ${question.options
                      .map(
                        (option, index) => `
                        <div class="ranking-item" draggable="true" data-option="${option}" data-original-index="${index}">
                            <div class="ranking-number">${index + 1}</div>
                            <div class="ranking-text">${option}</div>
                            <div class="drag-handle">⋮⋮</div>
                        </div>
                    `
                      )
                      .join("")}
                </div>
            `;
      }

      function generateCardHTML(question, questionId) {
        const safeId = createSafeId(questionId);
        return `
                <div class="card-options">
                    ${question.options
                      .map(
                        (option, index) => `
                        <div class="card-option" onclick="FinanceEngine.selectCardOption(this, '${questionId}', ${index})">
                            <input type="radio" name="q${safeId}" value="${escapeHtml(
                          option.title
                        )}" data-option-value="${escapeHtml(option.title)}">
                            <div class="card-option-title">${option.title}</div>
                            ${
                              option.subtitle
                                ? `<div class="card-option-subtitle">${
                                    Array.isArray(option.subtitle)
                                      ? option.subtitle.join("<br>")
                                      : option.subtitle
                                  }</div>`
                                : ""
                            }
                        </div>
                    `
                      )
                      .join("")}
                </div>
                ${
                  question.followUp
                    ? `<div id="followUp_${questionId}" style="display: none; margin-top: 20px;"></div>`
                    : ""
                }
            `;
      }

      function generateCheckboxHTML(question, questionId) {
        const maxSelections = question.maxSelections || question.options.length;
        return `
                <div class="checkbox-options">
                    ${question.options
                      .map(
                        (option, index) => `
                        <div class="checkbox-option" onclick="FinanceEngine.toggleCheckboxOption(this, '${questionId}', ${maxSelections})">
                            <input type="checkbox" value="${escapeHtml(
                              option
                            )}" data-option-value="${escapeHtml(option)}">
                            <div class="checkbox-option-label">${option}</div>
                        </div>
                    `
                      )
                      .join("")}
                </div>
                ${
                  maxSelections < question.options.length
                    ? `<p style="font-size: 0.9em; color: #666; text-align: center;">Select up to ${maxSelections} options</p>`
                    : ""
                }
            `;
      }

      function generateTextHTML(question, questionId) {
        return `
                <textarea class="text-input" placeholder="${
                  question.placeholder || ""
                }" 
                    maxlength="${question.maxLength || 500}" 
                    oninput="FinanceEngine.handleTextInput(this, '${questionId}', ${
          question.maxLength || 500
        })"
                    ${
                      question.required && question.required !== false
                        ? "required"
                        : ""
                    }></textarea>
                <div class="char-counter">0/${question.maxLength || 500}</div>
                ${
                  question.required === false
                    ? '<p style="font-size: 0.9em; color: #666; text-align: center; margin-top: 5px;">Optional</p>'
                    : ""
                }
            `;
      }

      function generateSliderHTML(question, questionId) {
        const defaultValue =
          question.min !== undefined && question.max !== undefined
            ? Math.round((question.min + question.max) / 2)
            : 5;
        return `
                <div class="slider-container">
                    <div class="slider-value">${defaultValue}</div>
                    <input type="range" class="slider-input" 
                        min="${question.min || 1}" max="${
          question.max || 10
        }" step="${question.step || 1}" 
                        value="${defaultValue}"
                        oninput="FinanceEngine.handleSliderInput(this, '${questionId}')">
                    <div class="slider-labels">
                        <span>${question.minLabel || "Low"}</span>
                        <span>${question.maxLabel || "High"}</span>
                    </div>
                </div>
            `;
      }

      function generateMultiSliderHTML(question, questionId) {
        return `
                <div class="matrix-slider-container">
                    ${question.options
                      .map(
                        (option, index) => `
                        <div class="matrix-slider-item">
                            <div class="matrix-slider-label">${option}</div>
                            <div class="matrix-slider-value">5</div>
                            <input type="range" class="matrix-slider-input" 
                                min="${question.min || 1}" max="${
                          question.max || 10
                        }" step="${question.step || 1}" value="5"
                                oninput="FinanceEngine.handleMatrixSliderInput(this, '${questionId}', ${index})">
                            <div class="matrix-slider-scale">
                                <span>${question.minLabel || "Low"}</span>
                                <span>${question.maxLabel || "High"}</span>
                            </div>
                        </div>
                    `
                      )
                      .join("")}
                </div>
            `;
      }

      function generateSelectHTML(question, questionId) {
        const safeId = createSafeId(questionId);
        return `
                <div class="select-options">
                    ${question.options
                      .map(
                        (option, index) => `
                        <div class="select-option" onclick="FinanceEngine.selectSingleChoice(this, '${questionId}', ${index})">
                            <input type="radio" name="q${safeId}" value="${escapeHtml(
                          option
                        )}" data-option-value="${escapeHtml(option)}">
                            <div class="select-option-label">${option}</div>
                        </div>
                    `
                      )
                      .join("")}
                </div>
            `;
      }

      // Finance Engine namespace with interaction handlers
      const FinanceEngine = {
        selectCardOption: function (element, questionId, index) {
          console.log(
            `🃏 Card option selected for finance question ${questionId}, index: ${index}`
          );
          initializeQuestionState(questionId);

          const siblings = element.parentElement.children;
          for (let sibling of siblings) {
            sibling.classList.remove("selected");
            sibling.querySelector("input").checked = false;
          }

          element.classList.add("selected");
          const radio = element.querySelector("input");
          radio.checked = true;

          // Handle follow-up questions
          const question = this.findQuestionById(questionId);
          if (
            question.followUp &&
            radio.value.includes(question.followUp.condition)
          ) {
            this.showFollowUp(questionId, question.followUp);
          } else {
            this.hideFollowUp(questionId);
          }

          console.log(`📊 Card selection for ${questionId}:`, radio.value);
          this.updateResponse(questionId, radio.value, "card");
        },

        selectSingleChoice: function (element, questionId, index) {
          console.log(
            `📋 Single choice selected for finance question ${questionId}, index: ${index}`
          );
          initializeQuestionState(questionId);

          const siblings = element.parentElement.children;
          for (let sibling of siblings) {
            sibling.classList.remove("selected");
            sibling.querySelector("input").checked = false;
          }

          element.classList.add("selected");
          const radio = element.querySelector("input");
          radio.checked = true;

          console.log(
            `📊 Single choice selection for ${questionId}:`,
            radio.value
          );
          this.updateResponse(questionId, radio.value, "select");
        },

        toggleCheckboxOption: function (
          element,
          questionId,
          maxSelections = 999
        ) {
          console.log(`✅ Checkbox toggle for finance question ${questionId}`);
          initializeQuestionState(questionId);

          const checkbox = element.querySelector('input[type="checkbox"]');
          const container = element.parentElement;
          const selectedCount =
            container.querySelectorAll("input:checked").length;

          if (!checkbox.checked && selectedCount >= maxSelections) {
            showStatusMessage(
              `Maximum ${maxSelections} selections allowed`,
              "info"
            );
            return;
          }

          checkbox.checked = !checkbox.checked;
          element.classList.toggle("selected", checkbox.checked);

          const selectedValues = this.getCheckboxValues(container);
          console.log(`📊 Checkbox values for ${questionId}:`, selectedValues);
          this.updateResponse(questionId, selectedValues, "checkbox");
        },

        handleTextInput: function (input, questionId, maxLength) {
          console.log(
            `📝 Text input for finance question ${questionId}: ${input.value.length} chars`
          );
          initializeQuestionState(questionId);

          const value = input.value;
          const counter = input.nextElementSibling;

          if (counter) {
            counter.textContent = `${value.length}/${maxLength}`;
          }

          console.log(`📊 Text value for ${questionId}:`, value);
          this.updateResponse(questionId, value, "text");
        },

        handleSliderInput: function (input, questionId) {
          console.log(
            `🎚️ Slider input for finance question ${questionId}: ${input.value}`
          );
          initializeQuestionState(questionId);

          const value = parseInt(input.value);
          const valueDisplay = input.previousElementSibling;

          if (valueDisplay && valueDisplay.classList.contains("slider-value")) {
            valueDisplay.textContent = value;
          }

          console.log(`📊 Slider value for ${questionId}:`, value);
          this.updateResponse(questionId, value, "slider");
        },

        handleMatrixSliderInput: function (input, questionId, index) {
          console.log(
            `🎛️ Matrix-slider input for finance question ${questionId}, slider ${index}: ${input.value}`
          );
          initializeQuestionState(questionId);

          const value = parseInt(input.value);
          const valueDisplay = input.previousElementSibling;
          if (
            valueDisplay &&
            valueDisplay.classList.contains("matrix-slider-value")
          ) {
            valueDisplay.textContent = value;
          }

          const sliderContainer = input.closest(".matrix-slider-container");
          const sliders = sliderContainer.querySelectorAll(
            ".matrix-slider-input"
          );
          const questionData = this.findQuestionById(questionId);

          const sliderValues = {};
          Array.from(sliders).forEach((slider, i) => {
            const questionText = questionData.options[i];
            sliderValues[questionText] = parseInt(slider.value);
          });

          console.log(
            `📊 Matrix-slider values for ${questionId}:`,
            sliderValues
          );
          this.updateResponse(questionId, sliderValues, "multi-slider");
        },

        handleTableInput: function (questionId, tableType) {
          console.log(
            `📋 Table input for finance question ${questionId}, type: ${tableType}`
          );
          initializeQuestionState(questionId);

          const tableData = this.getTableData(questionId, tableType);
          console.log(`📊 Table data for ${questionId}:`, tableData);
          this.updateResponse(questionId, tableData, "financial-table");
        },

        triggerFileUpload: function (questionId) {
          const fileInput = document.getElementById(`fileInput_${questionId}`);
          fileInput.click();
        },

        handleFileSelect: function (event, questionId) {
          const files = Array.from(event.target.files);
          this.processFiles(files, questionId);
        },

        handleFileDrop: function (event, questionId) {
          event.preventDefault();
          event.stopPropagation();

          const uploadZone = event.currentTarget;
          uploadZone.classList.remove("dragover");

          const files = Array.from(event.dataTransfer.files);
          this.processFiles(files, questionId);
        },

        handleDragOver: function (event) {
          event.preventDefault();
          event.currentTarget.classList.add("dragover");
        },

        handleDragLeave: function (event) {
          event.currentTarget.classList.remove("dragover");
        },

        processFiles: async function (files, questionId) {
          console.log(
            `📁 Processing ${files.length} files for question ${questionId}`
          );

          if (!uploadedFiles[questionId]) {
            uploadedFiles[questionId] = [];
          }

          for (const file of files) {
            try {
              // Convert file to PDF if needed (simulation)
              const processedFile = await this.convertToPDF(file);
              uploadedFiles[questionId].push(processedFile);

              console.log(`✅ File processed: ${file.name}`);
            } catch (error) {
              console.error(`❌ Error processing file ${file.name}:`, error);
            }
          }

          this.updateFileDisplay(questionId);
          this.updateResponse(
            questionId,
            uploadedFiles[questionId],
            "file-upload"
          );
        },

        convertToPDF: async function (file) {
          // Simulate PDF conversion - in real implementation, this would call a conversion service
          return {
            originalName: file.name,
            processedName: file.name.replace(/\.[^/.]+$/, ".pdf"),
            size: file.size,
            type: "application/pdf",
            uploadedAt: new Date().toISOString(),
            conversionStatus:
              file.type === "application/pdf" ? "original" : "converted",
          };
        },

        updateFileDisplay: function (questionId) {
          const container = document.getElementById(
            `uploadedFiles_${questionId}`
          );
          if (!container) return;

          const files = uploadedFiles[questionId] || [];

          container.innerHTML = files
            .map(
              (file, index) => `
                    <div class="uploaded-file">
                        <div class="file-info">
                            <span>📄</span>
                            <span>${file.processedName}</span>
                            <span style="font-size: 0.8em; color: #666;">(${this.formatFileSize(
                              file.size
                            )})</span>
                            ${
                              file.conversionStatus === "converted"
                                ? '<span style="font-size: 0.8em; color: #4caf50;">Converted to PDF</span>'
                                : ""
                            }
                        </div>
                        <button class="file-remove" onclick="FinanceEngine.removeFile('${questionId}', ${index})">Remove</button>
                    </div>
                `
            )
            .join("");
        },

        removeFile: function (questionId, index) {
          if (uploadedFiles[questionId]) {
            uploadedFiles[questionId].splice(index, 1);
            this.updateFileDisplay(questionId);
            this.updateResponse(
              questionId,
              uploadedFiles[questionId],
              "file-upload"
            );
          }
        },

        formatFileSize: function (bytes) {
          if (bytes === 0) return "0 Bytes";
          const k = 1024;
          const sizes = ["Bytes", "KB", "MB", "GB"];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return (
            parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i]
          );
        },

        getTableData: function (questionId, tableType) {
          const isHistorical = tableType === "historical";
          const columns = isHistorical
            ? ["twoYearsAgo", "lastYear", "currentYTD"]
            : ["thisYear", "nextYear", "inTwoYears"];
          const rows = ["revenue", "gross_profit", "net_profit"];

          const data = {};

          rows.forEach((row) => {
            data[row] = {};
            columns.forEach((col, index) => {
              const fieldId = `${questionId}_${row}_${index + 1}`;
              const input = document.getElementById(fieldId);
              data[row][col] = input ? parseFloat(input.value) || 0 : 0;
            });
          });

          return {
            tableType: tableType,
            data: data,
            metadata: {
              currency: "USD",
              completedFields: this.countCompletedTableFields(questionId),
              totalFields: rows.length * columns.length,
            },
          };
        },

        countCompletedTableFields: function (questionId) {
          const inputs = document.querySelectorAll(
            `input[id^="${questionId}_"]`
          );
          let completed = 0;
          inputs.forEach((input) => {
            if (input.value && parseFloat(input.value) > 0) completed++;
          });
          return completed;
        },

        showFollowUp: function (questionId, followUp) {
          const container = document.getElementById(`followUp_${questionId}`);
          if (!container) return;

          let html = `
                    <div style="background: #f8fbff; padding: 20px; border-radius: 12px; border: 2px solid #bbdefb;">
                        <h4 style="color: #0f4c75; margin-bottom: 15px;">${followUp.question}</h4>
                `;

          if (followUp.type === "select") {
            html += `
                        <div class="select-options">
                            ${followUp.options
                              .map(
                                (option, index) => `
                                <div class="select-option" onclick="FinanceEngine.selectFollowUp('${questionId}', '${option}')">
                                    <div class="select-option-label">${option}</div>
                                </div>
                            `
                              )
                              .join("")}
                        </div>
                    `;
          } else if (followUp.type === "text") {
            html += `
                        <textarea class="text-input" placeholder="${
                          followUp.placeholder || ""
                        }" 
                            maxlength="${followUp.maxLength || 100}" 
                            oninput="FinanceEngine.handleFollowUpText(this, '${questionId}', ${
              followUp.maxLength || 100
            })"></textarea>
                        <div class="char-counter">0/${
                          followUp.maxLength || 100
                        }</div>
                    `;
          }

          html += "</div>";
          container.innerHTML = html;
          container.style.display = "block";
        },

        hideFollowUp: function (questionId) {
          const container = document.getElementById(`followUp_${questionId}`);
          if (container) {
            container.style.display = "none";
          }
        },

        selectFollowUp: function (questionId, value) {
          console.log(`📋 Follow-up selected for ${questionId}:`, value);

          // Update main response to include follow-up
          const existingResponse = responses[questionId];
          if (existingResponse) {
            existingResponse.followUp = {
              selected_option: value,
              answered_at: new Date().toISOString(),
            };

            if (backendConnected) {
              autoSaveResponse(questionId, existingResponse);
            }
          }

          // Visual feedback
          const container = document.getElementById(`followUp_${questionId}`);
          const options = container.querySelectorAll(".select-option");
          options.forEach((option) => {
            option.classList.remove("selected");
            if (option.textContent.trim() === value) {
              option.classList.add("selected");
            }
          });
        },

        handleFollowUpText: function (input, questionId, maxLength) {
          const value = input.value;
          const counter = input.nextElementSibling;

          if (counter) {
            counter.textContent = `${value.length}/${maxLength}`;
          }

          // Update main response to include follow-up
          const existingResponse = responses[questionId];
          if (existingResponse) {
            existingResponse.followUp = {
              response_text: value,
              answered_at: new Date().toISOString(),
            };

            if (backendConnected) {
              autoSaveResponse(questionId, existingResponse);
            }
          }
        },

        getCheckboxValues: function (container) {
          const checked = container.querySelectorAll("input:checked");
          return Array.from(checked).map((input) => input.value);
        },

        findQuestionById: function (questionId) {
          for (const assessmentType in assessmentQuestions) {
            const question = assessmentQuestions[assessmentType].find(
              (q) => q.id === questionId
            );
            if (question) return question;
          }
          return null;
        },

        updateResponse: function (questionId, value, questionType) {
          console.log(
            `🔄 Updating finance response for question ${questionId}:`,
            value
          );
          initializeQuestionState(questionId);

          const now = new Date();
          const timeSpent = Math.floor(
            (now - questionStartTimes[questionId]) / 1000
          );
          const questionData = this.findQuestionById(questionId);

          const isFirstAnswer = !questionStates[questionId].first_answered_at;
          questionStates[questionId] = {
            ...questionStates[questionId],
            status: "completed",
            first_answered_at: isFirstAnswer
              ? now.toISOString()
              : questionStates[questionId].first_answered_at,
            last_modified_at: now.toISOString(),
            modification_count: isFirstAnswer
              ? 0
              : (questionStates[questionId].modification_count || 0) + 1,
          };

          let responseData = {};

          switch (questionType) {
            case "card":
              responseData = {
                selected_option: {
                  value: value,
                  label: value,
                },
              };
              break;

            case "select":
              responseData = {
                selected_option: value,
              };
              break;

            case "checkbox":
              responseData = {
                selected_options: value,
                selection_metadata: {
                  total_selections: value.length,
                },
              };
              break;

            case "text":
              const wordCount = value
                .trim()
                .split(/\s+/)
                .filter((word) => word.length > 0).length;

              responseData = {
                response_text: value,
                response_status: "completed",
                character_count: value.length,
                word_count: wordCount,
              };
              break;

            case "slider":
              responseData = {
                selected_value: value,
                selection_metadata: {
                  normalized_value: value / 10,
                },
              };
              break;

            case "multi-slider":
              responseData = {
                slider_values: value,
                response_metadata: {
                  total_sliders: Object.keys(value).length,
                  completion_rate: 1,
                },
              };
              break;

            case "financial-table":
              responseData = {
                table_data: value,
                completion_metadata: {
                  table_type: value.tableType,
                  completed_fields: value.metadata.completedFields,
                  total_fields: value.metadata.totalFields,
                  completion_rate:
                    value.metadata.completedFields / value.metadata.totalFields,
                },
              };
              break;

            case "file-upload":
              // Handle both array format (old) and object format (new categorized files)
              let allFiles = [];
              if (Array.isArray(value)) {
                // Old format: value is array of files
                allFiles = value;
              } else if (value && typeof value === 'object') {
                // New format: value is object with categories containing arrays of files
                allFiles = Object.values(value).flat();
              }
              
              responseData = {
                uploaded_files: value,
                file_metadata: {
                  total_files: allFiles.length,
                  total_size: allFiles.reduce((sum, file) => {
                    const fileSize = file.originalFile?.size || file.size || 0;
                    return sum + fileSize;
                  }, 0),
                  file_types: [...new Set(allFiles.map((file) => file.originalFile?.type || file.type || 'unknown'))],
                },
              };
              break;

            case "ranking":
              responseData = {
                ranked_options: value,
                ranking_metadata: {
                  total_items: value.length,
                  ranking_complete: true,
                },
              };
              break;

            default:
              responseData = { selected_value: value };
          }

          const response = {
            question_id: questionId,
            assessment_type: currentAssessment,
            section: questionData ? questionData.section : "Unknown",
            question_type: questionType,
            question_text: questionData ? questionData.question : "Unknown",
            response_format: this.getResponseFormat(questionType),
            response_data: responseData,
            all_options: questionData ? questionData.options : [],
            metadata: {
              time_spent_seconds: timeSpent,
              final_answer_confidence: "high",
              assessment_context: {
                current_assessment: currentAssessment,
                question_number: questionData ? questionData.number : "unknown",
                section_name: questionData ? questionData.section : "unknown",
              },
            },
            answered_at: now.toISOString(),
            last_modified_at: now.toISOString(),
          };

          responses[questionId] = response;
          console.log(`💾 Finance response saved for ${questionId}:`, response);

          if (currentUserId && backendConnected) {
            autoSaveResponse(questionId, response);
          } else {
            showAutoSaveIndicator("saved");
          }

          updateProgress();
        },

        getResponseFormat: function (questionType) {
          const formatMap = {
            card: "string",
            select: "string",
            checkbox: "array",
            text: "text",
            slider: "numeric",
            "multi-slider": "object",
            "financial-table": "table",
            "file-upload": "files",
            ranking: "ranked_list",
          };
          return formatMap[questionType] || "string";
        },

        // ADD ALL NEW METHODS HERE
        triggerCategoryUpload: function (categoryKey) {
          const fileInput = document.getElementById(`fileInput_${categoryKey}`);
          fileInput.click();
        },

        handleCategoryFileSelect: function (event, categoryKey) {
          const files = Array.from(event.target.files);
          this.processCategoryFiles(files, categoryKey);
        },

        handleCategoryDrop: function (event, categoryKey) {
          event.preventDefault();
          event.stopPropagation();

          const uploadZone = event.currentTarget;
          uploadZone.classList.remove("dragover");

          const files = Array.from(event.dataTransfer.files);
          this.processCategoryFiles(files, categoryKey);
        },

        processCategoryFiles: async function (files, categoryKey) {
          // Use the new blob-first approach by default, with fallback to legacy
          if (this.processingMethod === 'blob-first') {
            return await this.processCategoryFilesViaBlob(files, categoryKey);
          } else {
            return await this.processCategoryFilesLegacy(files, categoryKey);
          }
        },

        // Keep the old method as legacy fallback
        processCategoryFilesLegacy: async function (files, categoryKey) {
          console.log(
            `📁 Processing ${files.length} files for category ${categoryKey} (LEGACY)`
          );

          const category = documentCategories[categoryKey];

          // Validate file count
          const currentFiles = uploadedFiles[categoryKey] || [];
          if (currentFiles.length + files.length > category.maxFiles) {
            showStatusMessage(
              `Maximum ${category.maxFiles} files allowed for ${category.title}`,
              "error"
            );
            return;
          }

          for (const file of files) {
            try {
              // Show processing status
              this.updateProcessingStatus(categoryKey, file.name, "uploading");

              // Send to PDF AI endpoint immediately
              const extractedData = await this.sendToPDFAI(file, categoryKey);

              // Store the result
              uploadedFiles[categoryKey].push({
                originalFile: {
                  name: file.name,
                  size: file.size,
                  type: file.type,
                },
                extractedData: extractedData,
                category: categoryKey,
                uploadedAt: new Date().toISOString(),
                processingStatus: "completed",
              });

              this.updateProcessingStatus(categoryKey, file.name, "completed");
              console.log(`✅ File processed for ${categoryKey}: ${file.name}`);
            } catch (error) {
              console.error(
                `❌ Error processing file ${file.name} for ${categoryKey}:`,
                error
              );
              this.updateProcessingStatus(
                categoryKey,
                file.name,
                "error",
                error.message
              );
            }
          }

          this.updateCategoryFileDisplay(categoryKey);
          this.updateDocumentUploadResponse();
        },

        sendToPDFAI: async function (file, categoryKey) {
          const category = documentCategories[categoryKey];

          this.updateProcessingStatus(categoryKey, file.name, "uploading");

          // Create FormData for file upload
          const formData = new FormData();
          formData.append("file", file);
          formData.append("category", categoryKey);
          formData.append("user_id", currentUserId);
          formData.append("business_name", currentBusinessName);

          this.updateProcessingStatus(categoryKey, file.name, "processing");

          // Call backend upload endpoint - no JSON returned
          const response = await fetch(`${API_BASE_URL}${category.endpoint}`, {
            method: "POST",
            body: formData,
          });

          if (!response.ok) {
            throw new Error(`File upload failed: ${response.statusText}`);
          }

          const result = await response.json();

          // Backend just confirms upload, no JSON data
          return {
            fileId: result.file_id,
            uploadConfirmed: true,
            status: result.status,
          };
        },

        updateProcessingStatus: function (
          categoryKey,
          fileName,
          status,
          errorMessage = null
        ) {
          const statusDiv = document.getElementById(
            `processingStatus_${categoryKey}`
          );
          if (!statusDiv) return;

          const statusMessages = {
            uploading: "📤 Uploading...",
            processing: "🔄 Queued for AI processing...",
            completed: "✅ Uploaded successfully",
            error: `❌ Error: ${errorMessage}`,
          };

          const statusColors = {
            uploading: "#2196f3",
            processing: "#ff9800",
            completed: "#4caf50",
            error: "#f44336",
          };

          statusDiv.innerHTML = `
         <div style="background: ${statusColors[status]}15; border: 1px solid ${statusColors[status]}; 
                     border-radius: 8px; padding: 10px; margin: 5px 0; font-size: 0.9em;">
             <strong>${fileName}:</strong> ${statusMessages[status]}
         </div>
     `;
        },

        updateCategoryFileDisplay: function (categoryKey) {
          const container = document.getElementById(
            `uploadedFiles_${categoryKey}`
          );
          if (!container) return;

          const files = uploadedFiles[categoryKey] || [];

          if (files.length === 0) {
            container.innerHTML = `
              <div style="text-align: center; color: #666; padding: 20px; font-style: italic;">
                No files uploaded yet for ${documentCategories[categoryKey].title}
              </div>
            `;
            return;
          }

          container.innerHTML = files
            .map(
              (fileData, index) => {
                const uploadDate = fileData.uploadedAt ? new Date(fileData.uploadedAt).toLocaleString() : 'Unknown date';
                const isSuccess = fileData.extractedData && !fileData.error;
                const statusIcon = isSuccess ? '✅' : (fileData.error ? '❌' : '⏳');
                const statusText = isSuccess ? 'Processed' : (fileData.error ? 'Failed' : 'Processing');
                
                return `
         <div class="uploaded-file" style="border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; margin: 8px 0; background: ${isSuccess ? '#f8fff8' : (fileData.error ? '#fff8f8' : '#f8f8ff')};">
             <div class="file-info" style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                 <span style="font-size: 1.2em;">${documentCategories[categoryKey].icon}</span>
                 <div style="flex: 1;">
                   <div style="font-weight: 600; color: #333;">${fileData.originalFile.name}</div>
                   <div style="font-size: 0.8em; color: #666;">
                     Size: ${this.formatFileSize(fileData.originalFile.size)} | 
                     Uploaded: ${uploadDate}
                   </div>
                 </div>
                 <div style="display: flex; align-items: center; gap: 8px;">
                   <span style="font-size: 0.9em; color: ${isSuccess ? '#4caf50' : (fileData.error ? '#f44336' : '#ff9800')};">
                     ${statusIcon} ${statusText}
                   </span>
                 </div>
             </div>
             <div style="display: flex; justify-content: space-between; align-items: center;">
               <div style="font-size: 0.8em; color: #666;">
                 ${fileData.extractedData ? `${Object.keys(fileData.extractedData).length} fields extracted` : (fileData.error ? `Error: ${fileData.error}` : 'Processing...')}
               </div>
               <button 
                 class="file-remove" 
                 onclick="FinanceEngine.removeCategoryFile('${categoryKey}', ${index}, event)"
                 style="background: #f44336; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8em;"
                 onmouseover="this.style.background='#d32f2f'"
                 onmouseout="this.style.background='#f44336'"
               >
                 🗑️ Delete
               </button>
             </div>
         </div>
     `;
              }
            )
            .join("");
        },

        removeCategoryFile: async function (categoryKey, index, event) {
          if (!uploadedFiles[categoryKey] || !uploadedFiles[categoryKey][index]) {
            console.error(`❌ No file found at category ${categoryKey}, index ${index}`);
            return;
          }

          const fileData = uploadedFiles[categoryKey][index];
          const fileName = fileData.originalFile?.name || 'Unknown file';
          const fileId = fileData.file_id;

          if (!fileId) {
            console.warn(`⚠️ No file_id found for ${fileName}, removing from display only`);
            // Remove from frontend display only (for files not yet saved to database)
            uploadedFiles[categoryKey].splice(index, 1);
            this.updateCategoryFileDisplay(categoryKey);
            this.updateDocumentUploadResponse();
            return;
          }

          // Show loading state
          const button = event?.target;
          const originalButtonText = button?.innerHTML || '🗑️ Delete';
          
          try {
            console.log(`🗑️ Deleting file: ${fileName} (file_id: ${fileId})`);
            
            if (button) {
              button.disabled = true;
              button.innerHTML = '⏳ Deleting...';
            }

            // Call backend delete API
            const response = await makeAPICall(`/finance_document/${fileId}`, 'DELETE');

            if (response && response.status === 'deleted') {
              console.log(`✅ Successfully deleted ${fileName} from database`);
              
              // Remove from frontend display
              uploadedFiles[categoryKey].splice(index, 1);
              this.updateCategoryFileDisplay(categoryKey);
              this.updateDocumentUploadResponse();
              
              // Show success message
              showStatusMessage(`File "${fileName}" successfully deleted`, 'success');
              
            } else {
              throw new Error('Delete request failed');
            }

          } catch (error) {
            console.error(`❌ Error deleting file ${fileName}:`, error);
            
            // Reset button state
            if (button) {
              button.disabled = false;
              button.innerHTML = originalButtonText;
            }
            
            // Show error message
            showStatusMessage(`Failed to delete "${fileName}": ${error.message}`, 'error');
          }
        },

        updateDocumentUploadResponse: function () {
          const questionId = "i0.1";
          const allUploadedData = {};

          Object.keys(uploadedFiles).forEach((categoryKey) => {
            allUploadedData[categoryKey] = uploadedFiles[categoryKey];
          });

          this.updateResponse(questionId, allUploadedData, "file-upload");
        },

        // ======================================================
        //           NEW BLOB-FIRST UPLOAD FUNCTIONS
        // ======================================================

        sendToBlobFirst: async function (file, categoryKey, usePolling = true) {
          const category = documentCategories[categoryKey];
          
          this.updateProcessingStatusAdvanced(categoryKey, file.name, "uploading", "Preparing upload...", 5);

          // Create FormData for blob-first upload
          const formData = new FormData();
          formData.append("file", file);
          formData.append("category", categoryKey);
          formData.append("user_id", currentUserId);
          formData.append("business_name", currentBusinessName);
          formData.append("use_polling", usePolling);

          try {
            // Use XMLHttpRequest for upload progress tracking
            const result = await new Promise((resolve, reject) => {
              const xhr = new XMLHttpRequest();
              
              // Track upload progress
              xhr.upload.addEventListener('progress', (event) => {
                if (event.lengthComputable) {
                  const percentComplete = Math.round((event.loaded / event.total) * 100);
                  const progress = Math.min(percentComplete * 0.4, 40); // Upload is 40% of total process
                  
                  console.log(`📤 UPLOAD PROGRESS: ${file.name} - ${percentComplete}% (${this.formatFileSize(event.loaded)}/${this.formatFileSize(event.total)})`);
                  this.updateProcessingStatusAdvanced(
                    categoryKey, 
                    file.name, 
                    "uploading", 
                    `Uploading... ${percentComplete}% (${this.formatFileSize(event.loaded)}/${this.formatFileSize(event.total)})`, 
                    progress
                  );
                }
              });
              
              // Handle upload completion
              xhr.addEventListener('load', () => {
                if (xhr.status >= 200 && xhr.status < 300) {
                  try {
                    console.log(`✅ UPLOAD COMPLETE: ${file.name}`);
                    this.updateProcessingStatusAdvanced(categoryKey, file.name, "processing", "Upload complete, processing...", 45);
                    const response = JSON.parse(xhr.responseText);
                    resolve(response);
                  } catch (error) {
                    reject(new Error(`Invalid JSON response: ${error.message}`));
                  }
                } else {
                  reject(new Error(`Upload failed: ${xhr.status} ${xhr.statusText}`));
                }
              });
              
              // Handle upload errors
              xhr.addEventListener('error', () => {
                reject(new Error('Upload failed due to network error'));
              });
              
              // Handle upload timeout
              xhr.addEventListener('timeout', () => {
                reject(new Error('Upload timed out'));
              });
              
              // Configure and send request
              xhr.open('POST', `${API_BASE_URL}/process_financial_document_blob_first`);
              xhr.timeout = 300000; // 5 minute timeout
              xhr.send(formData);
            });

            console.log(`🎯 UPLOAD RESULT: ${file.name}`, result);

            if (usePolling && result.job_id) {
              // Start polling for async job
              this.updateProcessingStatusAdvanced(categoryKey, file.name, "processing", "Document uploaded, starting extraction...", 30);
              return await this.pollExtractionJob(result.job_id, categoryKey, file.name);
            } else {
              // Synchronous processing completed
              this.updateProcessingStatusAdvanced(categoryKey, file.name, "completed", "Processing completed successfully!", 100);
              return {
                success: true,
                fileId: result.file_id,
                blobUrl: result.blob_url,
                extractedData: result,
                processingType: result.processing_type
              };
            }

          } catch (error) {
            this.updateProcessingStatusAdvanced(categoryKey, file.name, "error", `Upload failed: ${error.message}`, 0);
            throw error;
          }
        },

        pollExtractionJob: async function (jobId, categoryKey, fileName, maxAttempts = 120) {
          let attempts = 0;
          const pollStartTime = performance.now();
          let lastSuccessfulPoll = Date.now();
          
          console.log(`🔄 POLLING START: Job ${jobId} for ${fileName}`);
          console.log(`🔄 POLLING DEBUG: Max attempts: ${maxAttempts}, Interval: 2s (Azure timeout resilient)`);
          
          while (attempts < maxAttempts) {
            try {
              const pollAttemptTime = performance.now();
              console.log(`🔍 POLLING ATTEMPT ${attempts + 1}/${maxAttempts}: Checking job ${jobId} (${fileName})`);
              
              // Azure timeout-resilient fetch with reasonable timeout
              const response = await fetch(`${API_BASE_URL}/extraction_job_status/${jobId}`, {
                method: "GET",
                headers: {
                  'Cache-Control': 'no-cache',
                  'Connection': 'keep-alive'
                }
              });
              lastSuccessfulPoll = Date.now();

              if (!response.ok) {
                throw new Error(`Polling failed: ${response.statusText}`);
              }

              const jobStatus = await response.json();
              
              // Enhanced status logging
              const status = jobStatus.status || 'unknown';
              const progress = jobStatus.progress || 0;
              const message = jobStatus.message || 'Processing...';
              const elapsedTime = (performance.now() - pollStartTime) / 1000;
              
              console.log(`📊 POLLING STATUS: ${fileName} - Status: ${status}, Progress: ${progress}%, Time: ${elapsedTime.toFixed(1)}s`);
              console.log(`💬 POLLING MESSAGE: ${message}`);
              
              // Update UI with enhanced status messages
              let displayMessage = message;
              if (status === 'extracting') {
                displayMessage = `${message} (${elapsedTime.toFixed(0)}s elapsed)`;
              }
              
              this.updateProcessingStatusAdvanced(
                categoryKey, 
                fileName, 
                jobStatus.status === 'completed' ? 'completed' : 'processing',
                displayMessage,
                Math.max(progress, 45) // Ensure we're past upload phase
              );

              if (jobStatus.status === 'completed') {
                // Job completed successfully
                const totalTime = elapsedTime;
                console.log(`✅ POLLING SUCCESS: ${fileName} completed in ${totalTime.toFixed(2)}s after ${attempts + 1} attempts`);
                console.log(`📊 FINAL RESULT: Job ${jobId}`, jobStatus.result ? 'Has result data' : 'No result data');
                
                return {
                  success: true,
                  fileId: jobStatus.job_id,
                  blobUrl: jobStatus.blob_url,
                  extractedData: jobStatus.result,
                  processingType: 'async_with_polling',
                  totalTime: jobStatus.time_elapsed || totalTime
                };
              } else if (jobStatus.status === 'failed') {
                // Job failed
                console.error(`❌ POLLING FAILED: ${fileName} - ${jobStatus.error || 'Unknown error'}`);
                throw new Error(jobStatus.error || 'Extraction job failed');
              }

              // Job still in progress, wait and retry
              console.log(`⏳ POLLING WAIT: ${fileName} still ${status}, waiting 2s for next attempt...`);
              await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds
              attempts++;

            } catch (error) {
              const timeSinceLastSuccess = Date.now() - lastSuccessfulPoll;
              
              console.error(`❌ POLLING ERROR attempt ${attempts + 1}/${maxAttempts} for ${fileName}:`, error.message);
              console.error(`🕐 Time since last successful poll: ${Math.round(timeSinceLastSuccess/1000)}s`);
              
              // Handle Azure timeout scenarios
              if (error.name === 'AbortError' || error.message.includes('timeout') || error.message.includes('network')) {
                console.warn(`🌐 AZURE TIMEOUT DETECTED for ${fileName} - implementing resilience strategy`);
                
                // Store job info for recovery
                this.storeIncompleteJob(jobId, categoryKey, fileName, {
                  startTime: pollStartTime,
                  lastPoll: lastSuccessfulPoll,
                  attempts: attempts
                });
                
                // Update UI to show resilience mode
                this.updateProcessingStatusAdvanced(
                  categoryKey, 
                  fileName, 
                  'processing',
                  `Connection timeout - retrying... (${Math.round(timeSinceLastSuccess/1000)}s since last check)`,
                  60
                );
              }
              
              attempts++;
              
              if (attempts >= maxAttempts) {
                console.error(`💀 POLLING TIMEOUT: ${fileName} failed after ${maxAttempts} attempts`);
                
                // Store failed job for manual recovery
                this.storeIncompleteJob(jobId, categoryKey, fileName, {
                  startTime: pollStartTime,
                  lastPoll: lastSuccessfulPoll,
                  attempts: attempts,
                  status: 'timeout'
                });
                
                this.updateProcessingStatusAdvanced(
                  categoryKey, 
                  fileName, 
                  "error", 
                  `Polling timeout after ${Math.round(timeSinceLastSuccess/1000)}s - job may still be running. Check 'Recovery' tab.`, 
                  0
                );
                throw new Error(`Extraction polling timeout after ${maxAttempts} attempts - job stored for recovery`);
              }
              
              // Exponential backoff for resilience
              const waitTime = Math.min(3000 + (attempts * 1000), 10000);
              console.log(`⏳ POLLING ERROR WAIT: ${fileName} waiting ${waitTime/1000}s before retry (exponential backoff)...`);
              await new Promise(resolve => setTimeout(resolve, waitTime));
            }
          }
          
          throw new Error("Extraction polling timeout - job may still be running");
        },

        // ======================================================
        //         AZURE TIMEOUT RESILIENCE & JOB RECOVERY
        // ======================================================

        storeIncompleteJob: function(jobId, categoryKey, fileName, jobInfo) {
          try {
            const incompleteJobs = JSON.parse(localStorage.getItem('incompleteExtractionJobs') || '{}');
            const jobKey = `${jobId}`;
            
            incompleteJobs[jobKey] = {
              jobId: jobId,
              categoryKey: categoryKey,
              fileName: fileName,
              storedAt: Date.now(),
              userId: currentUserId,
              businessName: currentBusinessName,
              ...jobInfo
            };
            
            localStorage.setItem('incompleteExtractionJobs', JSON.stringify(incompleteJobs));
            console.log(`💾 STORED INCOMPLETE JOB: ${fileName} (${jobId}) for recovery`);
            
            // Update recovery UI
            this.updateRecoveryUI();
          } catch (error) {
            console.error('Failed to store incomplete job:', error);
          }
        },

        getIncompleteJobs: function() {
          try {
            return JSON.parse(localStorage.getItem('incompleteExtractionJobs') || '{}');
          } catch (error) {
            console.error('Failed to get incomplete jobs:', error);
            return {};
          }
        },

        recoverJob: async function(jobKey) {
          const incompleteJobs = this.getIncompleteJobs();
          const job = incompleteJobs[jobKey];
          
          if (!job) {
            console.error(`Job ${jobKey} not found in recovery storage`);
            return;
          }
          
          console.log(`🔄 RECOVERING JOB: ${job.fileName} (${job.jobId})`);
          
          try {
            // Try to resume polling
            const result = await this.pollExtractionJob(job.jobId, job.categoryKey, job.fileName, 60);
            
            if (result.success) {
              console.log(`✅ RECOVERY SUCCESS: ${job.fileName} completed`);
              
              // Remove from incomplete jobs
              delete incompleteJobs[jobKey];
              localStorage.setItem('incompleteExtractionJobs', JSON.stringify(incompleteJobs));
              this.updateRecoveryUI();
              
              return result;
            }
          } catch (error) {
            console.error(`❌ RECOVERY FAILED: ${job.fileName}:`, error.message);
            
            // Update job status to show recovery failed
            job.lastRecoveryAttempt = Date.now();
            job.recoveryError = error.message;
            incompleteJobs[jobKey] = job;
            localStorage.setItem('incompleteExtractionJobs', JSON.stringify(incompleteJobs));
          }
        },

        clearExpiredJobs: function() {
          const incompleteJobs = this.getIncompleteJobs();
          const now = Date.now();
          const maxAge = 24 * 60 * 60 * 1000; // 24 hours
          let cleared = 0;
          
          for (const [jobKey, job] of Object.entries(incompleteJobs)) {
            if (now - job.storedAt > maxAge) {
              delete incompleteJobs[jobKey];
              cleared++;
            }
          }
          
          if (cleared > 0) {
            localStorage.setItem('incompleteExtractionJobs', JSON.stringify(incompleteJobs));
            console.log(`🧹 CLEANED UP: Removed ${cleared} expired jobs from recovery storage`);
          }
        },

        updateRecoveryUI: function() {
          const incompleteJobs = this.getIncompleteJobs();
          const jobCount = Object.keys(incompleteJobs).length;
          
          // Add recovery indicator to UI (you could enhance this further)
          console.log(`🔄 RECOVERY STATUS: ${jobCount} jobs available for recovery`);
          
          if (jobCount > 0) {
            console.log(`📋 INCOMPLETE JOBS:`, Object.entries(incompleteJobs).map(([key, job]) => 
              `${job.fileName} (${Math.round((Date.now() - job.storedAt) / 1000 / 60)}m ago)`
            ));
          }
        },

        // Auto-recovery on page load
        initializeRecovery: function() {
          this.clearExpiredJobs();
          const incompleteJobs = this.getIncompleteJobs();
          
          if (Object.keys(incompleteJobs).length > 0) {
            console.log(`🔄 FOUND ${Object.keys(incompleteJobs).length} INCOMPLETE JOBS - Auto-attempting recovery...`);
            
            // Auto-attempt recovery for recent jobs (< 10 minutes old)
            const now = Date.now();
            for (const [jobKey, job] of Object.entries(incompleteJobs)) {
              const ageMinutes = (now - job.storedAt) / 1000 / 60;
              
              if (ageMinutes < 10 && !job.lastRecoveryAttempt) {
                console.log(`🚀 AUTO-RECOVERING: ${job.fileName} (${ageMinutes.toFixed(1)}m ago)`);
                setTimeout(() => this.recoverJob(jobKey), 2000); // Slight delay to avoid overwhelming
              }
            }
          }
        },

        updateProcessingStatusAdvanced: function (categoryKey, fileName, status, message, progress = 0) {
          const statusDiv = document.getElementById(`processingStatus_${categoryKey}`);
          if (!statusDiv) return;

          const statusColors = {
            uploading: "#2196f3",
            processing: "#ff9800", 
            completed: "#4caf50",
            error: "#f44336",
          };

          const statusIcons = {
            uploading: "📤",
            processing: "🔄",
            completed: "✅", 
            error: "❌"
          };

          // Create progress bar if in processing
          const progressBarHtml = (status === 'processing' || status === 'uploading') ? 
            `<div style="background: #f0f0f0; border-radius: 4px; margin: 5px 0; overflow: hidden;">
               <div style="background: ${statusColors[status]}; height: 6px; width: ${progress}%; transition: width 0.5s ease;"></div>
             </div>` : '';

          statusDiv.innerHTML = `
            <div style="background: ${statusColors[status]}15; border: 1px solid ${statusColors[status]}; 
                        border-radius: 8px; padding: 12px; margin: 5px 0; font-size: 0.9em;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                    <span style="font-size: 1.1em;">${statusIcons[status]}</span>
                    <strong>${fileName}</strong>
                    ${progress > 0 ? `<span style="font-size: 0.8em; color: #666;">(${progress}%)</span>` : ''}
                </div>
                <div style="color: #555; font-size: 0.85em;">${message}</div>
                ${progressBarHtml}
            </div>
          `;
        },

        // Update the main processCategoryFiles to use blob-first approach
        processCategoryFilesViaBlob: async function (files, categoryKey) {
          console.log(`🚀 PARALLEL PROCESSING: Starting ${files.length} files for category ${categoryKey} via BLOB-FIRST approach`);

          const category = documentCategories[categoryKey];

          // Validate file count
          const currentFiles = uploadedFiles[categoryKey] || [];
          if (currentFiles.length + files.length > category.maxFiles) {
            showStatusMessage(
              `Maximum ${category.maxFiles} files allowed for ${category.title}`,
              "error"
            );
            return;
          }

          if (!uploadedFiles[categoryKey]) {
            uploadedFiles[categoryKey] = [];
          }

          // DETAILED LOGGING FOR PARALLEL PROCESSING
          console.log(`🔍 PARALLEL DEBUG: About to process ${files.length} files simultaneously`);
          console.log(`🔍 PARALLEL DEBUG: Files to process:`, files.map(f => `${f.name} (${this.formatFileSize(f.size)})`));
          console.log(`🔍 PARALLEL DEBUG: Category: ${categoryKey}`);
          console.log(`🔍 PARALLEL DEBUG: Start time: ${new Date().toISOString()}`);

          // Process files IN PARALLEL using Promise.allSettled
          const parallelStartTime = performance.now();
          const processingPromises = files.map(async (file, index) => {
            const fileStartTime = performance.now();
            
            console.log(`🚀 PARALLEL FILE ${index + 1}/${files.length}: Starting ${file.name}`);
            console.log(`🔍 PARALLEL DEBUG: File ${index + 1} details:`, {
              name: file.name,
              size: file.size,
              type: file.type,
              startTime: new Date().toISOString()
            });

            try {
              // Use new blob-first approach with polling
              console.log(`📤 PARALLEL FILE ${index + 1}: Calling sendToBlobFirst for ${file.name}`);
              const result = await this.sendToBlobFirst(file, categoryKey, true);
              
              const fileEndTime = performance.now();
              const fileProcessingTime = fileEndTime - fileStartTime;
              
              console.log(`✅ PARALLEL FILE ${index + 1}: SUCCESS for ${file.name}`);
              console.log(`⏱️ PARALLEL FILE ${index + 1}: Processing time: ${(fileProcessingTime / 1000).toFixed(2)}s`);
              console.log(`🔍 PARALLEL DEBUG: File ${index + 1} result:`, {
                success: true,
                fileId: result.fileId,
                blobUrl: result.blobUrl?.substring(0, 100) + '...',
                processingType: result.processingType,
                processingTimeMs: Math.round(fileProcessingTime)
              });

              return {
                success: true,
                file,
                result,
                index,
                processingTime: fileProcessingTime
              };
              
            } catch (error) {
              const fileEndTime = performance.now();
              const fileProcessingTime = fileEndTime - fileStartTime;
              
              console.error(`❌ PARALLEL FILE ${index + 1}: ERROR for ${file.name}:`, error);
              console.log(`⏱️ PARALLEL FILE ${index + 1}: Failed after: ${(fileProcessingTime / 1000).toFixed(2)}s`);
              console.error(`🔍 PARALLEL DEBUG: File ${index + 1} error:`, {
                success: false,
                fileName: file.name,
                error: error.message,
                processingTimeMs: Math.round(fileProcessingTime)
              });

              return {
                success: false,
                file,
                error,
                index,
                processingTime: fileProcessingTime
              };
            }
          });

          console.log(`⏳ PARALLEL DEBUG: Waiting for all ${files.length} files to complete...`);
          
          // Wait for all files to complete (parallel processing)
          const results = await Promise.allSettled(processingPromises);
          
          const parallelEndTime = performance.now();
          const totalParallelTime = parallelEndTime - parallelStartTime;

          console.log(`🎉 PARALLEL PROCESSING COMPLETE!`);
          console.log(`⏱️ PARALLEL DEBUG: Total parallel time: ${(totalParallelTime / 1000).toFixed(2)}s`);
          console.log(`🔍 PARALLEL DEBUG: Results summary:`, results.map((r, i) => ({
            fileIndex: i + 1,
            status: r.status,
            fileName: files[i].name,
            success: r.status === 'fulfilled' ? r.value.success : false
          })));

          // Process results and update storage
          let successCount = 0;
          let failureCount = 0;

          results.forEach((result, index) => {
            console.log(`📊 PARALLEL RESULT ${index + 1}/${files.length}:`);
            
            if (result.status === 'fulfilled') {
              const { success, file, result: processingResult, error, processingTime } = result.value;
              
              if (success) {
                successCount++;
                console.log(`✅ File ${index + 1} SUCCESS: ${file.name} (${(processingTime / 1000).toFixed(2)}s)`);
                
                // Store successful result
                uploadedFiles[categoryKey].push({
                  originalFile: {
                    name: file.name,
                    size: file.size,
                    type: file.type,
                  },
                  extractedData: processingResult.extractedData,
                  blobUrl: processingResult.blobUrl,
                  fileId: processingResult.fileId,
                  category: categoryKey,
                  uploadedAt: new Date().toISOString(),
                  processingStatus: "completed",
                  processingType: processingResult.processingType,
                  processingTime: Math.round(processingTime)
                });
              } else {
                failureCount++;
                console.error(`❌ File ${index + 1} FAILED: ${file.name} - ${error.message}`);
                
                // Store failed file info
                uploadedFiles[categoryKey].push({
                  originalFile: {
                    name: file.name,
                    size: file.size,
                    type: file.type,
                  },
                  error: error.message,
                  category: categoryKey,
                  uploadedAt: new Date().toISOString(),
                  processingStatus: "failed",
                  processingTime: Math.round(processingTime)
                });
              }
            } else {
              failureCount++;
              console.error(`💥 File ${index + 1} PROMISE REJECTED: ${files[index].name} - ${result.reason}`);
              
              // Store promise rejection
              uploadedFiles[categoryKey].push({
                originalFile: {
                  name: files[index].name,
                  size: files[index].size,
                  type: files[index].type,
                },
                error: `Promise rejected: ${result.reason}`,
                category: categoryKey,
                uploadedAt: new Date().toISOString(),
                processingStatus: "failed"
              });
            }
          });

          // Update UI display
          this.updateCategoryFileDisplay(categoryKey);
          this.updateDocumentUploadResponse();

          // Final summary with detailed logging
          console.log(`🎯 PARALLEL PROCESSING FINAL SUMMARY:`);
          console.log(`   📊 Total files: ${files.length}`);
          console.log(`   ✅ Successful: ${successCount}`);
          console.log(`   ❌ Failed: ${failureCount}`);
          console.log(`   ⏱️ Total time: ${(totalParallelTime / 1000).toFixed(2)}s`);
          console.log(`   📈 Average time per file: ${(totalParallelTime / files.length / 1000).toFixed(2)}s`);
          console.log(`   📂 Category: ${categoryKey}`);
          console.log(`   🕐 Completed at: ${new Date().toISOString()}`);
          
          showStatusMessage(
            `Parallel processing complete: ${successCount}/${files.length} files successful in ${(totalParallelTime / 1000).toFixed(1)}s`, 
            successCount === files.length ? "success" : "warning"
          );
        },

        // Toggle between old and new processing methods
        processingMethod: 'blob-first', // 'legacy' or 'blob-first'
        
        toggleProcessingMethod: function() {
          this.processingMethod = this.processingMethod === 'legacy' ? 'blob-first' : 'legacy';
          console.log(`🔄 Switched to ${this.processingMethod} processing method`);
          showStatusMessage(`Now using ${this.processingMethod} processing method`, "info");
          
          // Update UI display if elements exist
          if (typeof updateProcessingMethodDisplay === 'function') {
            updateProcessingMethodDisplay();
          }
        },
      };

      // Update processing method display
      function updateProcessingMethodDisplay() {
        const methodText = document.getElementById('currentMethodText');
        const methodDescription = document.getElementById('methodDescription');
        const toggleButton = document.getElementById('processingMethodToggle');
        
        if (!methodText || !methodDescription || !toggleButton) return;
        
        const method = FinanceEngine.processingMethod;
        
        if (method === 'blob-first') {
          methodText.textContent = 'Blob-First (Recommended)';
          methodDescription.innerHTML = '⚡ Enhanced reliability with blob storage, retry mechanism & polling for long operations';
          toggleButton.style.background = '#1976d2';
        } else {
          methodText.textContent = 'Legacy (Direct Processing)';
          methodDescription.innerHTML = '📤 Direct upload and processing - faster for small files but less reliable';
          toggleButton.style.background = '#ff9800';
        }
        
        console.log(`🔄 UI updated to show ${method} processing method`);
      }

      // Ranking functionality
      function initializeRanking(questionId) {
        console.log(`🎯 INITIALIZING RANKING for question: ${questionId}`);
        
        const container = document.getElementById(`ranking_${questionId}`);
        if (!container) {
          console.error(`❌ Container not found: ranking_${questionId}`);
          return;
        }
        console.log(`✅ Container found:`, container);

        const items = container.querySelectorAll(".ranking-item");
        console.log(`📝 Found ${items.length} ranking items`);

        if (items.length === 0) {
          console.error("❌ No ranking items found in container");
          return;
        }

        // Log initial state
        items.forEach((item, idx) => {
          const text = item.querySelector('.ranking-text')?.textContent || 'No text';
          console.log(`   Item ${idx}: "${text}" - draggable: ${item.draggable}`);
        });

        items.forEach((item, index) => {
          // Ensure item is draggable
          item.setAttribute('draggable', 'true');
          console.log(`🔧 Setting up item ${index}: draggable=${item.draggable}`);
          
          // Clear existing listeners by cloning (prevents duplicate listeners)
          const newItem = item.cloneNode(true);
          item.parentNode.replaceChild(newItem, item);
          newItem.setAttribute('draggable', 'true');
          
          newItem.addEventListener("dragstart", (e) => {
            console.log(`🚀 DRAGSTART: Item ${index}`);
            console.log(`   - Text: "${newItem.querySelector('.ranking-text')?.textContent}"`);
            console.log(`   - DataTransfer available: ${!!e.dataTransfer}`);
            console.log(`   - Item draggable: ${newItem.draggable}`);
            
            try {
              e.dataTransfer.setData("text/plain", index.toString());
              e.dataTransfer.effectAllowed = "move";
              newItem.classList.add("dragging");
              
              // Store additional data for debugging
              e.dataTransfer.setData("application/json", JSON.stringify({
                index: index,
                questionId: questionId,
                text: newItem.querySelector('.ranking-text')?.textContent
              }));
              
              console.log(`   ✅ Data stored: "${index}"`);
            } catch (error) {
              console.error(`   ❌ Error in dragstart:`, error);
            }
          });

          newItem.addEventListener("dragend", (e) => {
            console.log(`🏁 DRAGEND: Item ${index}`);
            newItem.classList.remove("dragging");
            // Clean up all drag states
            const allItems = container.querySelectorAll(".ranking-item");
            allItems.forEach(i => i.classList.remove("drag-over"));
          });

          newItem.addEventListener("dragenter", (e) => {
            console.log(`➡️ DRAGENTER: Item ${index}`);
            e.preventDefault();
          });

          newItem.addEventListener("dragover", (e) => {
            console.log(`🔄 DRAGOVER: Item ${index}`);
            e.preventDefault();
            e.dataTransfer.dropEffect = "move";
            newItem.classList.add("drag-over");
          });

          newItem.addEventListener("dragleave", (e) => {
            console.log(`⬅️ DRAGLEAVE: Item ${index}`);
            if (!newItem.contains(e.relatedTarget)) {
              newItem.classList.remove("drag-over");
            }
          });

          newItem.addEventListener("drop", (e) => {
            console.log(`💥 DROP EVENT on item ${index}`);
            console.log(`   - Event target: ${e.target.tagName}`);
            console.log(`   - Current target: ${e.currentTarget.tagName}`);
            
            e.preventDefault();
            e.stopPropagation();
            
            try {
              const draggedIndexStr = e.dataTransfer.getData("text/plain");
              const draggedIndex = parseInt(draggedIndexStr);
              const targetIndex = index;

              console.log(`   - Raw dragged data: "${draggedIndexStr}"`);
              console.log(`   - Parsed dragged index: ${draggedIndex}`);
              console.log(`   - Target index: ${targetIndex}`);
              console.log(`   - Valid number: ${!isNaN(draggedIndex)}`);
              
              // Try JSON data as backup
              try {
                const jsonData = e.dataTransfer.getData("application/json");
                if (jsonData) {
                  const parsed = JSON.parse(jsonData);
                  console.log(`   - JSON backup data:`, parsed);
                }
              } catch (jsonErr) {
                console.log(`   - No JSON backup data`);
              }

              newItem.classList.remove("drag-over");

              if (isNaN(draggedIndex)) {
                console.error(`❌ Invalid drag index - cannot reorder`);
                return;
              }

              if (draggedIndex === targetIndex) {
                console.log(`ℹ️ Same position drop, ignoring`);
                return;
              }

              console.log(`✅ CALLING reorderRankingItems(${draggedIndex} → ${targetIndex})`);
              reorderRankingItems(container, draggedIndex, targetIndex, questionId);
              
            } catch (error) {
              console.error(`❌ Error in drop handler:`, error);
            }
          });
        });
        
        console.log(`✅ Drag and drop setup complete for ${questionId}`);
      }

      function reorderRankingItems(container, fromIndex, toIndex, questionId) {
        console.log(`🔄 REORDER RANKING ITEMS START`);
        console.log(`   - Question ID: ${questionId}`);
        console.log(`   - From: ${fromIndex}, To: ${toIndex}`);
        
        const items = Array.from(container.querySelectorAll(".ranking-item"));
        console.log(`   - Total items found: ${items.length}`);
        
        // Log current state before reordering
        items.forEach((item, idx) => {
          const text = item.querySelector('.ranking-text')?.textContent || 'No text';
          const option = item.getAttribute('data-option');
          console.log(`     [${idx}] "${text}" (data-option: "${option}")`);
        });
        
        // Validation
        if (fromIndex < 0 || fromIndex >= items.length || toIndex < 0 || toIndex >= items.length) {
          console.error("❌ Invalid drag indices:", { fromIndex, toIndex, itemsLength: items.length });
          return;
        }
        
        const draggedItem = items[fromIndex];
        const draggedText = draggedItem.querySelector('.ranking-text')?.textContent || 'No text';
        console.log(`   - Dragged item: "${draggedText}"`);

        // Same position check
        if (fromIndex === toIndex) {
          console.log("ℹ️ Same position, no reordering needed");
          return;
        }

        // Remove dragged item from DOM
        console.log(`   - Removing dragged item from DOM...`);
        draggedItem.remove();

        // Get fresh list of items after removal
        const remainingItems = Array.from(container.querySelectorAll(".ranking-item"));
        console.log(`   - Remaining items after removal: ${remainingItems.length}`);
        
        // Calculate the correct insertion point
        let insertIndex = toIndex;
        if (fromIndex < toIndex) {
          insertIndex = toIndex - 1; // Adjust for removed item
        }
        
        console.log(`   - Calculated insert index: ${insertIndex}`);

        // Insert at new position
        if (insertIndex >= remainingItems.length) {
          console.log(`   - Appending to end`);
          container.appendChild(draggedItem);
        } else {
          console.log(`   - Inserting before item ${insertIndex}`);
          const targetItem = remainingItems[insertIndex];
          const targetText = targetItem?.querySelector('.ranking-text')?.textContent || 'No text';
          console.log(`   - Target item for insertion: "${targetText}"`);
          container.insertBefore(draggedItem, targetItem);
        }

        // Update ranking numbers
        console.log(`   - Updating ranking numbers...`);
        updateRankingNumbers(container);

        // Get final order
        const finalItems = Array.from(container.querySelectorAll(".ranking-item"));
        const rankedOptions = finalItems.map((item) => item.getAttribute("data-option"));
        
        console.log(`   - Final order:`);
        finalItems.forEach((item, idx) => {
          const text = item.querySelector('.ranking-text')?.textContent || 'No text';
          const option = item.getAttribute('data-option');
          console.log(`     [${idx + 1}] "${text}" (data-option: "${option}")`);
        });

        console.log(`   - Updating response with:`, rankedOptions);
        FinanceEngine.updateResponse(questionId, rankedOptions, "ranking");
        
        console.log(`✅ REORDER COMPLETE`);
        
        // Re-initialize drag and drop for the reordered items
        console.log(`🔄 Re-initializing drag and drop after reorder...`);
        setTimeout(() => {
          initializeRanking(questionId);
        }, 100);
      }

      function updateRankingNumbers(container) {
        const items = container.querySelectorAll(".ranking-item");
        items.forEach((item, index) => {
          const numberElement = item.querySelector(".ranking-number");
          numberElement.textContent = index + 1;
        });
      }

      // Utility functions
      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      function createSafeId(questionId) {
        return questionId.replace(/\./g, "_");
      }

      function initializeQuestionState(questionId) {
        if (!questionStates[questionId]) {
          console.log(`🆕 Initializing question state for ${questionId}`);
          questionStates[questionId] = {
            status: "in_progress",
            first_answered_at: null,
            last_modified_at: null,
            modification_count: 0,
          };
        }
        if (!questionStartTimes[questionId]) {
          questionStartTimes[questionId] = new Date();
        }
      }

      function getHistoricalFinancialData() {
        const historicalResponse = responses["f1.2"];
        return historicalResponse
          ? historicalResponse.response_data.table_data
          : null;
      }

      // Chapter timing
      function trackChapterTiming(sectionName) {
        const now = new Date();

        if (currentChapter && currentChapter !== sectionName) {
          finalizeCurrentChapterTiming();
        }

        if (currentChapter !== sectionName) {
          console.log(`📊 Starting chapter timing for: ${sectionName}`);
          currentChapter = sectionName;
          currentChapterStartTime = now;

          if (!chapterTimings[sectionName]) {
            chapterTimings[sectionName] = {
              chapter_name: sectionName,
              start_time: now.toISOString(),
              end_time: null,
              duration_seconds: 0,
              questions_answered: 0,
              first_question: null,
              last_question: null,
            };
          }
        }
      }

      function finalizeCurrentChapterTiming() {
        if (
          currentChapter &&
          currentChapterStartTime &&
          chapterTimings[currentChapter]
        ) {
          const now = new Date();
          const durationSeconds = Math.floor(
            (now - currentChapterStartTime) / 1000
          );

          chapterTimings[currentChapter].end_time = now.toISOString();
          chapterTimings[currentChapter].duration_seconds = durationSeconds;

          console.log(
            `✅ Finalized chapter timing for ${currentChapter}: ${durationSeconds}s`
          );
        }
      }

      // Auto-save functionality
      async function autoSaveResponse(questionId, responseData) {
        console.log(
          `💾 Auto-saving finance response for question ${questionId}`
        );

        if (!backendConnected || !currentUserId) {
          console.log(`⏭️ Skipping auto-save for ${questionId} - offline mode`);
          showAutoSaveIndicator("saved");
          return true;
        }

        showAutoSaveIndicator("saving");

        try {
          await saveProgressToBackend();

          console.log(`✅ Finance response auto-saved for ${questionId}`);
          showAutoSaveIndicator("saved");

          return true;
        } catch (error) {
          console.error(`❌ Auto-save failed for ${questionId}:`, error);
          showAutoSaveIndicator("error");
          return false;
        }
      }

      async function saveProgressToBackend() {
        if (!backendConnected || !currentUserId) {
          console.log("⏭️ Skipping progress save - offline mode or no user ID");
          return false;
        }

        try {
          console.log(`💾 Saving finance assessment progress to backend`);

          const assessmentData = buildFinanceAssessmentData();

          const response = await makeAPICall(
            "/finance_assessment_progress",
            "POST",
            {
              user_id: currentUserId,
              business_name: currentBusinessName,
              assessment_data: assessmentData,
              current_assessment: currentAssessment,
              auto_save: true,
            }
          );

          console.log("✅ Finance progress saved to backend:", response);
          return true;
        } catch (error) {
          console.error("❌ Finance progress save failed:", error);
          return false;
        }
      }

      // Show auto-save indicator
      function showAutoSaveIndicator(status) {
        if (!autoSaveIndicator) {
          autoSaveIndicator = document.createElement("div");
          autoSaveIndicator.className = "auto-save-indicator";

          const questionContainer = document.querySelector(".question");
          if (questionContainer) {
            questionContainer.appendChild(autoSaveIndicator);
          }
        }

        autoSaveIndicator.className = `auto-save-indicator ${status}`;

        switch (status) {
          case "saving":
            autoSaveIndicator.textContent = "💾 Saving...";
            break;
          case "saved":
            autoSaveIndicator.textContent = "✅ Saved";
            setTimeout(() => {
              if (autoSaveIndicator) autoSaveIndicator.style.display = "none";
            }, 2000);
            break;
          case "error":
            autoSaveIndicator.textContent = "❌ Save Error";
            break;
        }

        autoSaveIndicator.style.display = "block";
      }

      function restoreQuestionResponse(question) {
        const questionId = question.id;
        const savedResponse = responses[questionId];

        if (!savedResponse) return;

        console.log(
          `🔄 Restoring response for finance question ${questionId}:`,
          savedResponse
        );

        switch (question.type) {
          case "card":
            const cardOptions = document.querySelectorAll(".card-option");
            cardOptions.forEach((option) => {
              const input = option.querySelector("input");
              if (input && savedResponse.response_data.selected_option) {
                const savedValue =
                  savedResponse.response_data.selected_option.value ||
                  savedResponse.response_data.selected_option;
                if (input.value === savedValue) {
                  option.classList.add("selected");
                  input.checked = true;
                }
              }
            });
            break;

          case "checkbox":
            const checkboxOptions =
              document.querySelectorAll(".checkbox-option");
            const selectedOptions =
              savedResponse.response_data.selected_options || [];
            checkboxOptions.forEach((option) => {
              const input = option.querySelector("input");
              if (input && selectedOptions.includes(input.value)) {
                option.classList.add("selected");
                input.checked = true;
              }
            });
            break;

          case "text":
            const textInput = document.querySelector(".text-input");
            const charCounter = document.querySelector(".char-counter");
            if (textInput && savedResponse.response_data.response_text) {
              textInput.value = savedResponse.response_data.response_text;
              if (charCounter) {
                const maxLength = textInput.getAttribute("maxlength") || 500;
                charCounter.textContent = `${textInput.value.length}/${maxLength}`;
              }
            }
            break;

          case "slider":
            const slider = document.querySelector(".slider-input");
            const sliderValue = document.querySelector(".slider-value");
            if (
              slider &&
              savedResponse.response_data.selected_value !== undefined
            ) {
              slider.value = savedResponse.response_data.selected_value;
              if (sliderValue) {
                sliderValue.textContent =
                  savedResponse.response_data.selected_value;
              }
            }
            break;

          case "multi-slider":
            const sliders = document.querySelectorAll(".matrix-slider-input");
            const sliderValues = document.querySelectorAll(
              ".matrix-slider-value"
            );
            const savedSliderData =
              savedResponse.response_data.slider_values || {};

            sliders.forEach((slider, index) => {
              const questionText = question.options[index];
              if (savedSliderData[questionText] !== undefined) {
                slider.value = savedSliderData[questionText];
                if (sliderValues[index]) {
                  sliderValues[index].textContent =
                    savedSliderData[questionText];
                }
              }
            });
            break;

          case "select":
            const selectOptions = document.querySelectorAll(".select-option");
            selectOptions.forEach((option) => {
              const input = option.querySelector("input");
              if (
                input &&
                input.value === savedResponse.response_data.selected_option
              ) {
                option.classList.add("selected");
                input.checked = true;
              }
            });
            break;

          case "financial-table":
            const tableData = savedResponse.response_data.table_data;
            if (tableData && tableData.data) {
              Object.keys(tableData.data).forEach((row) => {
                Object.keys(tableData.data[row]).forEach((col, index) => {
                  const fieldId = `${questionId}_${row}_${index + 1}`;
                  const input = document.getElementById(fieldId);
                  if (input) {
                    input.value = tableData.data[row][col] || "";
                  }
                });
              });
            }
            break;

          case "file-upload":
            const uploadData = savedResponse.response_data.uploaded_files || {};
            Object.keys(uploadData).forEach((categoryKey) => {
              if (uploadedFiles[categoryKey] !== undefined) {
                uploadedFiles[categoryKey] = uploadData[categoryKey] || [];
                FinanceEngine.updateCategoryFileDisplay(categoryKey);
              }
            });
            break;

          case "ranking":
            // Restore ranking will be handled after DOM is ready
            setTimeout(() => {
              restoreRankingOrder(
                questionId,
                savedResponse.response_data.ranked_options
              );
            }, 500);
            break;
        }

        showAutoSaveIndicator("saved");
      }

      function restoreRankingOrder(questionId, rankedOptions) {
        const container = document.getElementById(`ranking_${questionId}`);
        if (!container || !rankedOptions) return;

        const items = Array.from(container.querySelectorAll(".ranking-item"));

        // Reorder items based on saved ranking
        rankedOptions.forEach((optionText, newIndex) => {
          const item = items.find(
            (item) => item.getAttribute("data-option") === optionText
          );
          if (item) {
            container.appendChild(item);
          }
        });

        updateRankingNumbers(container);
      }

      // Navigation functions
      function nextQuestion() {
        console.log(
          `➡️ Next finance question requested (current: ${
            currentQuestionIndex + 1
          })`
        );

        if (!currentAssessment) return;

        const questions = assessmentQuestions[currentAssessment];

        if (currentQuestionIndex < questions.length - 1) {
          console.log(
            `📝 Moving from question ${currentQuestionIndex + 1} to ${
              currentQuestionIndex + 2
            }`
          );
          showQuestion(currentQuestionIndex + 1);
          window.scrollTo(0, 0);
        } else {
          console.log("🏁 Reached end of assessment questions");
          showAssessmentComplete();
          window.scrollTo(0, 0);
        }
      }

      function previousQuestion() {
        console.log(
          `⬅️ Previous finance question requested (current: ${
            currentQuestionIndex + 1
          })`
        );

        if (!currentAssessment) return;

        if (currentQuestionIndex > 0) {
          console.log(
            `📝 Moving from question ${
              currentQuestionIndex + 1
            } to ${currentQuestionIndex}`
          );
          showQuestion(currentQuestionIndex - 1);
          window.scrollTo(0, 0);
        } else {
          console.log(
            "⚠️ Already at first question, returning to assessment selector"
          );
          returnToAssessmentSelector();
        }
      }

      function returnToAssessmentSelector() {
        console.log("🔙 Returning to assessment selector");

        // Hide current assessment content
        document.getElementById("assessmentHeader").style.display = "none";
        document.getElementById("navigationSection").style.display = "none";
        document.getElementById("assessmentContainer").innerHTML = "";

        // Show assessment selector
        document.getElementById("assessmentSelector").style.display = "block";

        // Update card status
        updateAssessmentCardStatus();

        currentAssessment = null;
        currentQuestionIndex = 0;

        finalizeCurrentChapterTiming();
      }

      function showAssessmentComplete() {
        console.log(`🎉 ${currentAssessment} assessment complete`);

        finalizeCurrentChapterTiming();

        const assessmentName = {
          foundation: "Financial Foundation",
          mastery: "Financial Mastery",
          intelligence: "Financial Intelligence",
        }[currentAssessment];

        const html = `
                <div class="assessment-content active">
                    <div class="assessment-header">
                        <h2 class="assessment-title">✅ ${assessmentName} Complete!</h2>
                        <p class="assessment-subtitle">Assessment ${
                          currentAssessment.charAt(0).toUpperCase() +
                          currentAssessment.slice(1)
                        } Finished</p>
                    </div>
                    
                    <div class="question">
                        <p style="text-align: center; font-size: 1.2em; margin-bottom: 30px;">
                            Excellent work! Your ${assessmentName.toLowerCase()} assessment is complete.
                        </p>
                        
                        <div style="background: rgba(15, 76, 117, 0.1); border: 2px solid #0f4c75; border-radius: 15px; padding: 25px; text-align: center; margin: 20px 0;">
                            <h3 style="color: #0f4c75; margin-bottom: 15px;">What's Next?</h3>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px;">
                                <button onclick="returnToAssessmentSelector()" style="padding: 15px; background: linear-gradient(135deg, #0f4c75, #3282b8); color: white; border: none; border-radius: 10px; font-weight: 600; cursor: pointer;">
                                    📊 Choose Another Assessment
                                </button>
                                <button onclick="showAllResults()" style="padding: 15px; background: linear-gradient(135deg, #4caf50, #388e3c); color: white; border: none; border-radius: 10px; font-weight: 600; cursor: pointer;">
                                    📈 View All Results
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

        document.getElementById("assessmentContainer").innerHTML = html;
        updateNavigation();
      }

      function showAllResults() {
        console.log("📊 Showing comprehensive finance results");

        // Check if all assessments are complete
        const foundationComplete =
          assessmentQuestions.foundation.filter((q) => responses[q.id])
            .length >=
          assessmentQuestions.foundation.length * 0.8;
        const masteryComplete =
          assessmentQuestions.mastery.filter((q) => responses[q.id]).length >=
          assessmentQuestions.mastery.length * 0.8;
        const intelligenceComplete =
          assessmentQuestions.intelligence.filter((q) => responses[q.id])
            .length >=
          assessmentQuestions.intelligence.length * 0.8;

        if (foundationComplete && masteryComplete && intelligenceComplete) {
          showFinalSection();
        } else {
          const completedAssessments = [];
          const pendingAssessments = [];

          if (foundationComplete) completedAssessments.push("Foundation");
          else pendingAssessments.push("Foundation");

          if (masteryComplete) completedAssessments.push("Mastery");
          else pendingAssessments.push("Mastery");

          if (intelligenceComplete) completedAssessments.push("Intelligence");
          else pendingAssessments.push("Intelligence");

          const html = `
                    <div class="assessment-content active">
                        <div class="assessment-header">
                            <h2 class="assessment-title">📊 Your Financial Progress</h2>
                            <p class="assessment-subtitle">Complete Assessment Overview</p>
                        </div>
                        
                        <div class="question">
                            <div style="background: rgba(76, 175, 80, 0.1); border: 2px solid #4caf50; border-radius: 15px; padding: 25px; margin: 20px 0;">
                                <h3 style="color: #4caf50; margin-bottom: 15px;">✅ Completed Assessments</h3>
                                ${
                                  completedAssessments.length > 0
                                    ? completedAssessments
                                        .map(
                                          (name) =>
                                            `<div style="margin: 10px 0; font-weight: 600;">• ${name}</div>`
                                        )
                                        .join("")
                                    : '<div style="color: #666;">No assessments completed yet</div>'
                                }
                            </div>
                            
                            ${
                              pendingAssessments.length > 0
                                ? `
                                <div style="background: rgba(255, 193, 7, 0.1); border: 2px solid #ffc107; border-radius: 15px; padding: 25px; margin: 20px 0;">
                                    <h3 style="color: #ff8f00; margin-bottom: 15px;">⏳ Pending Assessments</h3>
                                    ${pendingAssessments
                                      .map(
                                        (name) =>
                                          `<div style="margin: 10px 0; font-weight: 600;">• ${name}</div>`
                                      )
                                      .join("")}
                                </div>
                            `
                                : ""
                            }
                            
                            <div style="text-align: center; margin-top: 30px;">
                                ${
                                  pendingAssessments.length > 0
                                    ? `
                                    <p style="margin-bottom: 20px; color: #666;">Complete all assessments to generate your comprehensive Financial Intelligence Report</p>
                                    <button onclick="returnToAssessmentSelector()" style="padding: 15px 30px; background: linear-gradient(135deg, #0f4c75, #3282b8); color: white; border: none; border-radius: 10px; font-weight: 600; cursor: pointer;">
                                        Continue Remaining Assessments
                                    </button>
                                `
                                    : `
                                    <button onclick="showFinalSection()" style="padding: 15px 30px; background: linear-gradient(135deg, #4caf50, #388e3c); color: white; border: none; border-radius: 10px; font-weight: 600; cursor: pointer;">
                                        Generate Complete Financial Report
                                    </button>
                                `
                                }
                            </div>
                        </div>
                    </div>
                `;

          document.getElementById("assessmentContainer").innerHTML = html;
        }
      }

      function showFinalSection() {
        console.log("🏁 Showing final section");

        finalizeCurrentChapterTiming();

        // Clear assessment container
        document.getElementById("assessmentContainer").innerHTML = "";

        // Hide assessment header and navigation
        document.getElementById("assessmentHeader").style.display = "none";
        document.getElementById("navigationSection").style.display = "none";

        // Show final section
        const finalSection = document.getElementById("finalSection");
        finalSection.classList.add("active");

        // Update final section with progress stats
        updateFinalSectionStats();
      }

      function updateFinalSectionStats() {
        const totalResponses = Object.keys(responses).length;
        const foundationResponses = assessmentQuestions.foundation.filter(
          (q) => responses[q.id]
        ).length;
        const masteryResponses = assessmentQuestions.mastery.filter(
          (q) => responses[q.id]
        ).length;
        const intelligenceResponses = assessmentQuestions.intelligence.filter(
          (q) => responses[q.id]
        ).length;

        const finalSection = document.getElementById("finalSection");

        // Add completion stats
        let statsDiv = finalSection.querySelector(".completion-stats");
        if (!statsDiv) {
          statsDiv = document.createElement("div");
          statsDiv.className = "completion-stats";
          statsDiv.style.cssText = `
                    background: rgba(255, 255, 255, 0.9);
                    border-radius: 12px;
                    padding: 25px;
                    margin: 20px auto;
                    max-width: 600px;
                    text-align: center;
                    border: 1px solid #bbdefb;
                `;

          const subtitle = finalSection.querySelector(".final-subtitle");
          subtitle.parentNode.insertBefore(statsDiv, subtitle.nextSibling);
        }

        const assessmentDuration = Math.floor((new Date() - startTime) / 1000);
        const durationMinutes = Math.round(assessmentDuration / 60);

        statsDiv.innerHTML = `
                <div style="font-size: 1.2em; font-weight: 700; color: #0f4c75; margin-bottom: 20px;">
                    💰 Financial Intelligence Summary
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 20px; margin-bottom: 20px;">
                    <div>
                        <div style="font-size: 2em; font-weight: 800; color: #4caf50;">${foundationResponses}</div>
                        <div style="font-size: 0.9em; color: #666;">Foundation</div>
                    </div>
                    <div>
                        <div style="font-size: 2em; font-weight: 800; color: #2196f3;">${masteryResponses}</div>
                        <div style="font-size: 0.9em; color: #666;">Mastery</div>
                    </div>
                    <div>
                        <div style="font-size: 2em; font-weight: 800; color: #ff9800;">${intelligenceResponses}</div>
                        <div style="font-size: 0.9em; color: #666;">Intelligence</div>
                    </div>
                    <div>
                        <div style="font-size: 2em; font-weight: 800; color: #0f4c75;">${totalResponses}</div>
                        <div style="font-size: 0.9em; color: #666;">Total Answered</div>
                    </div>
                </div>
                <div style="font-size: 0.9em; color: #666;">
                    Session Duration: ${durationMinutes} minutes | Financial Command Analysis Ready
                </div>
            `;
      }

      function updateNavigation() {
        if (!currentAssessment) return;

        const questions = assessmentQuestions[currentAssessment];
        console.log(
          `🧭 Updating navigation for ${currentAssessment} question ${
            currentQuestionIndex + 1
          } of ${questions.length}`
        );

        const prevBtn = document.getElementById("prevBtn");
        const nextBtn = document.getElementById("nextBtn");
        const status = document.getElementById("questionStatus");

        // Previous button logic
        if (currentQuestionIndex === 0) {
          prevBtn.textContent = "← Choose Assessment";
          prevBtn.disabled = false;
        } else {
          prevBtn.textContent = "← Previous";
          prevBtn.disabled = false;
        }

        // Next button logic
        if (currentQuestionIndex === questions.length - 1) {
          nextBtn.textContent = "Complete Assessment →";
        } else {
          nextBtn.textContent = "Next Question →";
        }

        // Status text
        const totalResponses = Object.keys(responses).filter((id) =>
          assessmentQuestions[currentAssessment].some((q) => q.id === id)
        ).length;

        const assessmentName = {
          foundation: "Foundation",
          mastery: "Mastery",
          intelligence: "Intelligence",
        }[currentAssessment];

        status.textContent = `${assessmentName} ${
          currentQuestionIndex + 1
        } of ${questions.length} (${totalResponses} answered)`;

        console.log(`🧭 Finance navigation updated successfully`);
      }

      function updateProgress() {
        if (!currentAssessment) return;

        const questions = assessmentQuestions[currentAssessment];
        const answeredQuestions = questions.filter(
          (q) => responses[q.id]
        ).length;
        const percentage = Math.min(
          100,
          Math.floor((answeredQuestions / questions.length) * 100)
        );

        document.getElementById("progressFill").style.width = percentage + "%";
        document.getElementById(
          "progressText"
        ).textContent = `${percentage}% Complete (${answeredQuestions}/${questions.length} questions)`;
        document.getElementById("expansionIndicator").textContent = `${
          currentAssessment.charAt(0).toUpperCase() + currentAssessment.slice(1)
        } Assessment Progress`;

        console.log(
          `📊 ${currentAssessment} progress updated: ${percentage}% (${answeredQuestions}/${questions.length})`
        );
      }

      // Build complete finance assessment data
      function buildFinanceAssessmentData() {
        console.log("🏗️ Building comprehensive Finance assessment data...");
        const endTime = new Date();
        const totalEngagementTime = Math.floor((endTime - startTime) / 1000);

        // Organize responses by assessment type
        const responsesByAssessment = {
          foundation: [],
          mastery: [],
          intelligence: [],
        };

        Object.values(responses).forEach((response) => {
          const assessmentType = response.assessment_type || "foundation";
          if (responsesByAssessment[assessmentType]) {
            responsesByAssessment[assessmentType].push(response);
          }
        });

        // Calculate completion rates
        const completionRates = {};
        Object.keys(assessmentQuestions).forEach((type) => {
          const questions = assessmentQuestions[type];
          const answered = responsesByAssessment[type].length;
          completionRates[type] = {
            answered: answered,
            total: questions.length,
            percentage: Math.round((answered / questions.length) * 100),
          };
        });

        // Analyze financial patterns
        const historicalData = getHistoricalFinancialData();
        const revenuePattern = analyzeRevenuePattern(historicalData);

        const assessmentData = {
          assessment_metadata: {
            user_id: currentUserId,
            business_name: currentBusinessName,
            assessment_type: "backable_finance_engine",
            version: "1.0",
            created_at: startTime.toISOString(),
            last_updated: endTime.toISOString(),
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            session_metadata: {
              ...sessionMetadata,
              endTime: endTime.toISOString(),
              totalEngagementTime: totalEngagementTime,
              questionsAnswered: Object.keys(responses).length,
              revenueRange: currentRevenueRange,
              primaryChallenge: currentChallenge,
              growthTarget: currentGrowthTarget,
            },
            user_context: {
              revenue_range: currentRevenueRange,
              primary_challenge: currentChallenge,
              growth_target: currentGrowthTarget,
              revenue_pattern: revenuePattern,
            },
          },
          assessments: {
            foundation: {
              completion_rate: completionRates.foundation,
              responses: responsesByAssessment.foundation,
              key_insights: extractFoundationInsights(
                responsesByAssessment.foundation
              ),
            },
            mastery: {
              completion_rate: completionRates.mastery,
              responses: responsesByAssessment.mastery,
              key_insights: extractMasteryInsights(
                responsesByAssessment.mastery
              ),
            },
            intelligence: {
              completion_rate: completionRates.intelligence,
              responses: responsesByAssessment.intelligence,
              key_insights: extractIntelligenceInsights(
                responsesByAssessment.intelligence
              ),
            },
          },
          progress_tracking: {
            total_questions: Object.values(assessmentQuestions).flat().length,
            answered_questions: Object.keys(responses).length,
            completion_percentage: Math.round(
              (Object.keys(responses).length /
                Object.values(assessmentQuestions).flat().length) *
                100
            ),
            time_per_chapter: chapterTimings,
            uploaded_documents: Object.keys(uploadedFiles).reduce(
              (total, key) => total + (uploadedFiles[key] || []).length,
              0
            ),
            uploaded_files: uploadedFiles,
          },
          financial_analysis: {
            revenue_pattern: revenuePattern,
            historical_data: historicalData,
            growth_trajectory: calculateGrowthTrajectory(),
            financial_health_indicators: calculateFinancialHealthIndicators(),
          },
        };

        console.log("📊 Finance assessment data built:", assessmentData);
        return assessmentData;
      }

      function generateExtractionSummary() {
        const summary = {};
        Object.keys(uploadedFiles).forEach((categoryKey) => {
          const files = uploadedFiles[categoryKey] || [];
          summary[categoryKey] = {
            file_count: files.length,
            successful_extractions: files.filter(
              (f) => f.processingStatus === "completed"
            ).length,
            failed_extractions: files.filter(
              (f) => f.processingStatus === "error"
            ).length,
          };
        });
        return summary;
      }

      function extractFoundationInsights(responses) {
        const insights = {};

        responses.forEach((response) => {
          switch (response.question_id) {
            case "f1.1":
              insights.financial_year_end =
                response.response_data.selected_option;
              break;
            case "f1.4":
              insights.accounting_system =
                response.response_data.selected_option;
              if (response.followUp) {
                insights.accounting_software =
                  response.followUp.selected_option;
              }
              break;
            case "f1.5":
              insights.financial_review_frequency =
                response.response_data.selected_option;
              break;
            case "f1.6":
              insights.number_confidence =
                response.response_data.selected_option;
              break;
          }
        });

        return insights;
      }

      function extractMasteryInsights(responses) {
        const insights = {};

        responses.forEach((response) => {
          switch (response.question_id) {
            case "m1.1":
              insights.cash_flow_challenges =
                response.response_data.slider_values;
              break;
            case "m1.3":
              insights.cash_reserves_status =
                response.response_data.selected_option;
              break;
            case "m2.1":
              insights.current_funding_sources =
                response.response_data.selected_options;
              break;
            case "m3.1":
              insights.technology_sophistication =
                response.response_data.selected_option;
              break;
            case "m6.2":
              insights.estimated_business_value =
                response.response_data.selected_option;
              break;
          }
        });

        return insights;
      }

      function extractIntelligenceInsights(responses) {
        const insights = {};

        responses.forEach((response) => {
          switch (response.question_id) {
            case "i1.1":
              insights.profit_champions = response.response_data.response_text;
              break;
            case "i1.2":
              insights.margin_killers = response.response_data.response_text;
              break;
            case "i1.3":
              insights.quote_to_profit_gap =
                response.response_data.selected_option;
              break;
            case "i2.1":
              insights.cost_priority_ranking =
                response.response_data.ranked_options;
              break;
            case "i0.1":
              insights.uploaded_documents =
                response.response_data.uploaded_files;
              break;
          }
        });

        return insights;
      }

      function calculateGrowthTrajectory() {
        const historicalData = getHistoricalFinancialData();
        if (!historicalData || !historicalData.data) return null;

        const revenues = [
          historicalData.data.revenue.twoYearsAgo || 0,
          historicalData.data.revenue.lastYear || 0,
          historicalData.data.revenue.currentYTD || 0,
        ];

        const growth1 =
          revenues[1] > 0
            ? ((revenues[1] - revenues[0]) / revenues[0]) * 100
            : 0;
        const growth2 =
          revenues[2] > 0
            ? ((revenues[2] - revenues[1]) / revenues[1]) * 100
            : 0;

        return {
          year_over_year_growth: [growth1, growth2],
          average_growth_rate: (growth1 + growth2) / 2,
          growth_consistency:
            Math.abs(growth1 - growth2) < 10 ? "consistent" : "volatile",
          trajectory:
            growth1 > 0 && growth2 > 0
              ? "accelerating"
              : growth1 < 0 && growth2 < 0
              ? "declining"
              : "mixed",
        };
      }

      function calculateFinancialHealthIndicators() {
        const indicators = {
          cash_flow_health: "unknown",
          funding_diversity: "unknown",
          system_sophistication: "unknown",
          growth_readiness: "unknown",
        };

        // Cash flow health from mastery responses
        const cashReserves = responses["m1.3"];
        if (cashReserves) {
          const status =
            cashReserves.response_data.selected_option.value ||
            cashReserves.response_data.selected_option;
          if (
            status.includes("Perfect Conditions") ||
            status.includes("Clear Skies")
          ) {
            indicators.cash_flow_health = "strong";
          } else if (status.includes("Partly Sunny")) {
            indicators.cash_flow_health = "adequate";
          } else {
            indicators.cash_flow_health = "concerning";
          }
        }

        // Funding diversity
        const fundingSources = responses["m2.1"];
        if (fundingSources) {
          const sourceCount =
            fundingSources.response_data.selected_options.length;
          indicators.funding_diversity =
            sourceCount >= 3
              ? "diversified"
              : sourceCount >= 2
              ? "moderate"
              : "limited";
        }

        // System sophistication
        const techSetup = responses["m3.1"];
        if (techSetup) {
          const level = techSetup.response_data.selected_option;
          if (level.includes("Future State") || level.includes("Space Age")) {
            indicators.system_sophistication = "advanced";
          } else if (level.includes("Digital Age")) {
            indicators.system_sophistication = "modern";
          } else {
            indicators.system_sophistication = "basic";
          }
        }

        return indicators;
      }

      // Submit assessment
      async function submitFinanceAssessment() {
        console.log("🚀 Submitting Backable Finance Engine assessment...");

        const submitButton = document.querySelector(".submit-button");
        const originalText = submitButton.innerHTML;

        submitButton.innerHTML =
          'Generating Your Financial Intelligence Report... <div class="loading-spinner"></div>';
        submitButton.disabled = true;

        showStatusMessage(
          "Submitting your Financial Command Center profile...",
          "info"
        );

        try {
          const assessmentData = buildFinanceAssessmentData();

          console.log("📊 Final Finance data summary:", {
            totalQuestions: assessmentData.progress_tracking.total_questions,
            answeredQuestions:
              assessmentData.progress_tracking.answered_questions,
            completion:
              assessmentData.progress_tracking.completion_percentage + "%",
            foundationComplete:
              assessmentData.assessments.foundation.completion_rate.percentage +
              "%",
            masteryComplete:
              assessmentData.assessments.mastery.completion_rate.percentage +
              "%",
            intelligenceComplete:
              assessmentData.assessments.intelligence.completion_rate
                .percentage + "%",
          });

          if (backendConnected) {
            // Submit using finance-audit endpoint
            const reportResponse = await makeAPICall(
              `/finance-audit/${currentUserId}`,
              "POST",
              {
                user_id: currentUserId,
                business_name: currentBusinessName,
                assessment_data: assessmentData,
              }
            );

            if (reportResponse && reportResponse.status === "processing") {
              console.log(
                "✅ Finance assessment submitted successfully:",
                reportResponse
              );

              showStatusMessage(
                "🎉 Assessment submitted successfully! Your Financial Intelligence Report is being generated...",
                "success"
              );
              submitButton.innerHTML = "Financial Report Being Generated...";

              if (reportResponse.report_id) {
                pollFinanceReportStatus(reportResponse.report_id);
              }
            } else {
              throw new Error("Unexpected response format from server");
            }
          } else {
            console.log("📊 Finance assessment completed in offline mode");
            showStatusMessage(
              "🎉 Finance assessment completed! (Offline mode - data not saved to database)",
              "success"
            );
            submitButton.innerHTML = "Assessment Complete (Offline Mode)";
          }
        } catch (error) {
          console.error("❌ Finance submission error:", error);
          showStatusMessage(
            `❌ Error submitting assessment: ${error.message}. Assessment data has been captured locally.`,
            "error"
          );

          submitButton.innerHTML = originalText;
          submitButton.disabled = false;
        }
      }

      async function pollFinanceReportStatus(reportId) {
        console.log(`🔄 Polling finance report status for ${reportId}`);

        let pollCount = 0;
        const maxPolls = 60; // 5 minutes max

        const pollInterval = setInterval(async () => {
          pollCount++;

          try {
            const statusResponse = await makeAPICall(
              `/finance_report_status/${reportId}`
            );

            console.log(
              `📊 Finance report status poll ${pollCount}:`,
              statusResponse
            );

            if (statusResponse.status === "completed") {
              clearInterval(pollInterval);
              showStatusMessage(
                "🎉 Financial Intelligence Report completed successfully! Your financial command analysis has been generated and saved.",
                "success"
              );

              const submitButton = document.querySelector(".submit-button");
              submitButton.innerHTML =
                "Financial Report Generated Successfully!";
              submitButton.disabled = true;
            } else if (statusResponse.status === "failed") {
              clearInterval(pollInterval);
              showStatusMessage(
                `❌ Report generation failed: ${
                  statusResponse.error || "Unknown error"
                }`,
                "error"
              );

              const submitButton = document.querySelector(".submit-button");
              submitButton.innerHTML = "Report Generation Failed - Try Again";
              submitButton.disabled = false;
            } else if (statusResponse.status === "processing") {
              const message =
                statusResponse.message || "Analyzing financial intelligence...";
              const progress = statusResponse.progress || 0;
              showStatusMessage(`🔄 ${message} (${progress}%)`, "info");
            }

            if (pollCount >= maxPolls) {
              clearInterval(pollInterval);
              showStatusMessage(
                "⏰ Report generation is taking longer than expected. Please check back later.",
                "info"
              );
            }
          } catch (error) {
            console.error("❌ Error polling finance report status:", error);

            if (pollCount >= 5) {
              clearInterval(pollInterval);
              showStatusMessage(
                "⚠️ Unable to check report status. Your report may still be generating in the background.",
                "info"
              );
            }
          }
        }, 5000);
      }

      // Show status message
      function showStatusMessage(message, type = "info") {
        console.log(`📢 Status message (${type}): ${message}`);
        const statusDiv = document.getElementById("submission-status");
        if (statusDiv) {
          statusDiv.textContent = message;
          statusDiv.className = `status-message status-${type}`;
          statusDiv.style.display = "block";

          if (type !== "error") {
            setTimeout(() => {
              statusDiv.style.display = "none";
            }, 8000);
          }
        }
      }

      // Initialize when page loads
      document.addEventListener("DOMContentLoaded", async function () {
        console.log("🚀 Initializing Backable Finance Engine");

        // Check backend connection on startup
        await checkBackendConnection();
        
        // Initialize Azure timeout resilience system
        console.log("🛡️ Initializing Azure timeout resilience system");
        try {
          financeAssessmentModule.initializeRecovery();
          console.log("✅ Recovery system initialized successfully");
        } catch (error) {
          console.error("❌ Failed to initialize recovery system:", error);
        }

        // Set up event listeners
        console.log("🔗 Setting up event listeners...");
        const startButton = document.getElementById("startButton");
        if (startButton) {
          startButton.addEventListener("click", startFinanceAssessment);
          console.log("✅ Start button event listener added");
        } else {
          console.error("❌ Start button not found!");
        }
        document
          .getElementById("submitButton")
          .addEventListener("click", submitFinanceAssessment);
        document
          .getElementById("nextBtn")
          .addEventListener("click", nextQuestion);
        document
          .getElementById("prevBtn")
          .addEventListener("click", previousQuestion);

        console.log("✅ Backable Finance Engine initialized successfully");
        console.log(
          `   💰 Foundation questions: ${assessmentQuestions.foundation.length}`
        );
        console.log(
          `   ⚡ Mastery questions: ${assessmentQuestions.mastery.length}`
        );
        console.log(
          `   🧠 Intelligence questions: ${assessmentQuestions.intelligence.length}`
        );
        console.log(`   🌐 API URL: ${API_BASE_URL}`);
        console.log(`   💾 Backend Connected: ${backendConnected}`);
        console.log(
          `   📊 Auto-Save: ${
            backendConnected ? "Enabled" : "Disabled (offline mode)"
          }`
        );
      });

      // Keyboard navigation
      document.addEventListener("keydown", function (event) {
        if (assessmentStarted && currentAssessment) {
          const questions = assessmentQuestions[currentAssessment];

          if (
            event.key === "ArrowRight" &&
            currentQuestionIndex < questions.length - 1
          ) {
            console.log("⌨️ Keyboard: Next finance question");
            nextQuestion();
          } else if (event.key === "ArrowLeft" && currentQuestionIndex > 0) {
            console.log("⌨️ Keyboard: Previous finance question");
            previousQuestion();
          }
        }
      });

      // Global functions for assessment selection
      window.selectAssessment = selectAssessment;
      window.returnToAssessmentSelector = returnToAssessmentSelector;
      window.showAllResults = showAllResults;
      window.showFinalSection = showFinalSection;

      // Periodic connection check
      setInterval(async () => {
        if (!backendConnected) {
          await checkBackendConnection();
        }
      }, 30000);

      // Initialize drag and drop after question is shown
      function initializeDragAndDrop() {
        const rankingContainers =
          document.querySelectorAll(".ranking-container");
        rankingContainers.forEach((container) => {
          const questionId = container.id.replace("ranking_", "");
          initializeRanking(questionId);
        });
      }

      // Call after showing questions with ranking
      const originalShowQuestion = showQuestion;
      showQuestion = function (questionIndex) {
        originalShowQuestion(questionIndex);

        // Initialize drag and drop for ranking questions
        setTimeout(() => {
          initializeDragAndDrop();
        }, 200);
      };

      // Debug functions for development
      window.financeDebug = {
        // Basic debug functions
        getResponses: () => responses,
        getQuestionStates: () => questionStates,
        getAssessmentData: () => buildFinanceAssessmentData(),
        getAllQuestions: () => assessmentQuestions,
        
        // NEW: Blob-first processing controls
        getProcessingMethod: () => FinanceEngine.processingMethod,
        setProcessingMethod: (method) => {
          FinanceEngine.processingMethod = method;
          console.log(`🔄 Processing method set to: ${method}`);
          showStatusMessage(`Processing method changed to: ${method}`, "info");
        },
        toggleProcessingMethod: () => FinanceEngine.toggleProcessingMethod(),
        
        // Test blob-first upload
        testBlobUpload: async (file, category = 'profit_loss') => {
          console.log("🧪 Testing blob-first upload...");
          try {
            const result = await FinanceEngine.sendToBlobFirst(file, category, true);
            console.log("✅ Test blob upload result:", result);
            return result;
          } catch (error) {
            console.error("❌ Test blob upload failed:", error);
            throw error;
          }
        },
        
        // File Management Functions
        getUploadedFilesSummary: function() {
          console.log("📋 UPLOADED FILES SUMMARY");
          console.log("========================");
          
          let totalFiles = 0;
          let totalSuccessful = 0;
          let totalFailed = 0;
          let totalProcessing = 0;
          
          Object.keys(documentCategories).forEach(categoryKey => {
            const files = uploadedFiles[categoryKey] || [];
            const categoryName = documentCategories[categoryKey].title;
            
            console.log(`\n📁 ${categoryName} (${files.length} files):`);
            
            if (files.length === 0) {
              console.log("   ⚪ No files uploaded");
              return;
            }
            
            files.forEach((file, index) => {
              const status = file.extractedData && !file.error ? 'SUCCESS' : (file.error ? 'FAILED' : 'PROCESSING');
              const statusIcon = file.extractedData && !file.error ? '✅' : (file.error ? '❌' : '⏳');
              const uploadDate = file.uploadedAt ? new Date(file.uploadedAt).toLocaleString() : 'Unknown';
              
              console.log(`   ${statusIcon} ${file.originalFile.name} (${status}) - ${uploadDate}`);
              
              if (file.error) {
                console.log(`      Error: ${file.error}`);
              } else if (file.extractedData) {
                console.log(`      Fields: ${Object.keys(file.extractedData).length} extracted`);
              }
              
              totalFiles++;
              if (file.extractedData && !file.error) totalSuccessful++;
              else if (file.error) totalFailed++;
              else totalProcessing++;
            });
          });
          
          console.log(`\n📊 SUMMARY: ${totalFiles} total files`);
          console.log(`   ✅ ${totalSuccessful} successful`);
          console.log(`   ❌ ${totalFailed} failed`);
          console.log(`   ⏳ ${totalProcessing} processing`);
          
          return {
            totalFiles,
            totalSuccessful,
            totalFailed,
            totalProcessing,
            filesByCategory: Object.keys(documentCategories).reduce((acc, key) => {
              acc[key] = uploadedFiles[key] || [];
              return acc;
            }, {})
          };
        },
        
        clearUploadedFiles: function(categoryKey = null) {
          if (categoryKey) {
            // Clear specific category
            uploadedFiles[categoryKey] = [];
            this.updateCategoryFileDisplay(categoryKey);
            console.log(`🗑️ Cleared files for ${documentCategories[categoryKey].title}`);
          } else {
            // Clear all files
            Object.keys(documentCategories).forEach(key => {
              uploadedFiles[key] = [];
              this.updateCategoryFileDisplay(key);
            });
            console.log("🗑️ Cleared all uploaded files");
          }
          
          // Update backend
          this.updateDocumentUploadResponse();
          
          return this.getUploadedFilesSummary();
        },
        
        // Check extraction job status
        checkJobStatus: async (jobId) => {
          try {
            const response = await fetch(`${API_BASE_URL}/extraction_job_status/${jobId}`);
            const status = await response.json();
            console.log(`📊 Job ${jobId} status:`, status);
            return status;
          } catch (error) {
            console.error(`❌ Failed to check job ${jobId}:`, error);
            throw error;
          }
        },
        
        // List active extraction jobs
        getActiveJobs: async () => {
          try {
            const response = await fetch(`${API_BASE_URL}/active_extraction_jobs`);
            const jobs = await response.json();
            console.log("📋 Active extraction jobs:", jobs);
            return jobs;
          } catch (error) {
            console.error("❌ Failed to get active jobs:", error);
            throw error;
          }
        },
        getCurrentAssessment: () => currentAssessment,
        getUploadedFiles: () => uploadedFiles,

        // Assessment navigation
        jumpToAssessment: (type) => selectAssessment(type),
        jumpToQuestion: (questionIndex) => {
          if (currentAssessment) {
            showQuestion(questionIndex);
          }
        },

        // Data management
        clearAllResponses: () => {
          responses = {};
          questionStates = {};
          uploadedFiles = {};
          updateProgress();
          updateAssessmentCardStatus();
        },

        clearAssessmentResponses: (assessmentType) => {
          if (assessmentQuestions[assessmentType]) {
            assessmentQuestions[assessmentType].forEach((q) => {
              delete responses[q.id];
              delete questionStates[q.id];
            });
            updateProgress();
            updateAssessmentCardStatus();
          }
        },

        // Backend interaction
        checkConnection: () => checkBackendConnection(),
        saveProgress: () => saveProgressToBackend(),
        loadProgress: async (userId) =>
          await loadExistingProgress(userId || currentUserId),
        loadDocuments: async (userId) =>
          await loadUserDocuments(userId || currentUserId),
        
        // Debug function to test document loading for specific users
        debugLoadDocuments: async (userId) => {
          console.log(`🔧 DEBUG: Testing document loading for user ${userId}`);
          try {
            const response = await makeAPICall(`/finance_documents/${userId}`);
            console.log(`📊 DEBUG RESULT for user ${userId}:`, response);
            return response;
          } catch (error) {
            console.error(`❌ DEBUG ERROR for user ${userId}:`, error);
            return { error: error.message };
          }
        },
        
        // Debug function to test delete functionality
        debugDeleteFile: async (fileId) => {
          console.log(`🗑️ DEBUG: Testing file deletion for file_id: ${fileId}`);
          try {
            const response = await makeAPICall(`/finance_document/${fileId}`, 'DELETE');
            console.log(`📊 DELETE RESULT:`, response);
            return response;
          } catch (error) {
            console.error(`❌ DELETE ERROR:`, error);
            return { error: error.message };
          }
        },
        
        // Debug function to test ranking functionality
        debugRanking: (questionId) => {
          console.log(`🔍 DEBUGGING RANKING for ${questionId}`);
          
          const container = document.querySelector(`#ranking_${questionId}`);
          if (!container) {
            console.error(`❌ Ranking container not found for question: ${questionId}`);
            return null;
          }
          console.log(`✅ Container found:`, container);
          
          const items = Array.from(container.querySelectorAll('.ranking-item'));
          console.log(`📝 Items found: ${items.length}`);
          
          if (items.length === 0) {
            console.error(`❌ No ranking items found`);
            return null;
          }
          
          const currentOrder = items.map((item, index) => {
            const text = item.querySelector('.ranking-text')?.textContent || 'No text';
            const option = item.getAttribute('data-option');
            const draggable = item.draggable;
            const hasEventListeners = item.hasAttribute('data-drag-setup');
            
            return {
              position: index + 1,
              text: text,
              option: option,
              draggable: draggable,
              hasEventListeners: hasEventListeners
            };
          });
          
          console.log(`🔄 Current ranking state:`);
          currentOrder.forEach(item => {
            console.log(`   ${item.position}. "${item.text}" (draggable: ${item.draggable})`);
          });
          
          return currentOrder;
        },
        
        // Force re-initialize drag and drop
        reinitializeRanking: (questionId) => {
          console.log(`🔄 Force re-initializing ranking for ${questionId}`);
          initializeRanking(questionId);
          return `Drag and drop re-initialized for ${questionId}`;
        },
        
        // Test drag and drop setup
        testDragDrop: (questionId) => {
          console.log(`🧪 TESTING DRAG & DROP for ${questionId}`);
          
          const container = document.querySelector(`#ranking_${questionId}`);
          if (!container) {
            console.error(`❌ No container found`);
            return false;
          }
          
          const items = container.querySelectorAll('.ranking-item');
          console.log(`📝 Testing ${items.length} items:`);
          
          items.forEach((item, index) => {
            const text = item.querySelector('.ranking-text')?.textContent || 'No text';
            const draggable = item.getAttribute('draggable');
            const hasDragStart = item.ondragstart !== null;
            
            console.log(`   Item ${index}: "${text}"`);
            console.log(`     - draggable attribute: ${draggable}`);
            console.log(`     - draggable property: ${item.draggable}`);
            console.log(`     - has dragstart handler: ${hasDragStart}`);
          });
          
          return true;
        },

        // Financial analysis
        analyzeRevenue: () => {
          const historicalData = getHistoricalFinancialData();
          return analyzeRevenuePattern(historicalData);
        },

        getFinancialHealth: () => calculateFinancialHealthIndicators(),

        // Test functions
        simulateFoundationComplete: () => {
          assessmentQuestions.foundation.forEach((q) => {
            const testData = getTestResponseData(q.type);
            responses[q.id] = {
              question_id: q.id,
              assessment_type: "foundation",
              question_type: q.type,
              response_data: testData,
              answered_at: new Date().toISOString(),
            };
          });
          updateProgress();
          updateAssessmentCardStatus();
        },

        simulateMasteryComplete: () => {
          assessmentQuestions.mastery.forEach((q) => {
            const testData = getTestResponseData(q.type);
            responses[q.id] = {
              question_id: q.id,
              assessment_type: "mastery",
              question_type: q.type,
              response_data: testData,
              answered_at: new Date().toISOString(),
            };
          });
          updateProgress();
          updateAssessmentCardStatus();
        },

        testSubmission: async () => {
          return await submitFinanceAssessment();
        },
      };

      function getTestResponseData(questionType) {
        const testData = {
          card: {
            selected_option: { value: "Test Option", label: "Test Option" },
          },
          select: { selected_option: "Test Option" },
          checkbox: { selected_options: ["Test Option 1", "Test Option 2"] },
          text: { response_text: "Test financial response", word_count: 3 },
          slider: { selected_value: 5 },
          "multi-slider": { slider_values: { "Test Financial Factor": 7 } },
          "financial-table": {
            table_data: {
              tableType: "historical",
              data: {
                revenue: {
                  twoYearsAgo: 100000,
                  lastYear: 120000,
                  currentYTD: 140000,
                },
                gross_profit: {
                  twoYearsAgo: 50000,
                  lastYear: 60000,
                  currentYTD: 70000,
                },
                net_profit: {
                  twoYearsAgo: 20000,
                  lastYear: 25000,
                  currentYTD: 30000,
                },
              },
            },
          },
          "file-upload": { uploaded_files: [] },
          ranking: { ranked_options: ["Item 1", "Item 2", "Item 3"] },
        };

        return testData[questionType] || { test: true };
      }

      console.log(
        "🔬 Backable Finance Engine - Complete Financial Intelligence System!"
      );
      console.log(`   🔧 Debug functions available at window.financeDebug`);
      console.log(`   💾 Multi-assessment progress tracking with auto-save`);
      console.log(`   📁 File upload and PDF conversion capability`);
      console.log(`   📊 Dynamic content based on revenue pattern analysis`);
      console.log(
        `   🏆 Comprehensive behavioral analytics and financial health indicators`
      );
      console.log(`   🌐 Backend API: ${API_BASE_URL}`);
      console.log(`   💰 Three-part financial intelligence assessment system`);
    </script>
  </body>
</html>
